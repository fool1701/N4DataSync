<!-- Htmldoc has been run -->
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>
<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/build.html" class="navbar">Prev</a> |  <a href="/doc/slot-o-matic.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.javascript-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.css-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<h1 id="building-javascript-applications-for-niagara">Building JavaScript Applications for Niagara</h1>
<h2 id="contents">Contents</h2>
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#frameworksAndLibraries">Frameworks and Libraries</a></li>
  <li><a href="#settingUpYourEnvironment">Setting Up Your Environment</a>
    <ul>
      <li><a href="#nodeJs">Node.js</a></li>
      <li><a href="#npm">npm</a></li>
      <li><a href="#grunt">Grunt</a></li>
      <li><a href="#git">Git</a></li>
      <li><a href="#environmentVariables">Environment Variables</a></li>
    </ul>
  </li>
  <li><a href="#buildAndDevelopmentTools">Build and Development Tools</a>
    <ul>
      <li><a href="#npmModules">Open Source Niagara Development Utilities</a>
        <ul>
          <li><a href="#grunt-init-niagara">grunt-init-niagara</a></li>
          <li><a href="#grunt-niagara">grunt-niagara</a></li>
          <li><a href="#niagara-station">niagara-station</a></li>
          <li><a href="#niagara-test-server">niagara-test-server</a></li>
        </ul>
      </li>
      <li><a href="#niagaraRequireJSGradlePlugin">Building and Compacting your JavaScript</a></li>
      <li><a href="#moduledevMode">Developing in real time with <code>moduledev</code> mode</a></li>
    </ul>
  </li>
  <li><a href="#firstSteps">First Steps</a>
    <ul>
      <li><a href="#creatingANewModule">Creating a new module</a>
        <ul>
          <li><a href="#packageJson">package.json</a></li>
          <li><a href="#gruntfileJs">Gruntfile.js</a></li>
        </ul>
      </li>
      <li><a href="#watching">Watching</a></li>
      <li><a href="#aNoteOnContinuousIntegration">A note on Continuous Integration</a></li>
    </ul>
  </li>
  <li><a href="#buildingYourJavaScriptIntoANiagaraModule">Building your JavaScript into a Niagara module</a>
    <ul>
      <li><a href="#specifyingAdditionaGruntTasks">Specifying additional Grunt tasks</a></li>
      <li><a href="compactingUsingTheGradleRequireJSPlugin">Compacting using the Gradle RequireJS Plugin</a></li>
      <li><a href="#implementingBIJavaScript">Implementing BIJavaScript</a>
        <ul>
          <li><a href="#whatJavaScriptFileDefinesMyEditor">What JavaScript file defines my editor?</a></li>
          <li><a href="#whatTypesCanIEditWithMyEditor">What Types can I edit with my editor?</a></li>
        </ul>
      </li>
      <li><a href="#webdevMode">Switching your Station into Web Development mode</a></li>
    </ul>
  </li>
  <li><a href="#movingForward">Moving Forward</a></li>
  <li><a href="#appendix">Appendix</a>
    <ul>
      <li><a href="#migratingToGruntNiagara">Migrating from <code>niagara-rjs</code> to <code>grunt-niagara</code></a></li>
    </ul>
  </li>
</ul>
<p><a name="introduction"/></p>
<h1 id="introduction">Introduction</h1>
<p>In Niagara 4, the user interface is moving in a new direction with a heavy focus on HTML5 applications and open web technologies. Tridium provides a number of frameworks and utilities, intended to give developers the power to create their own web apps, from tiny field editors to powerful, full-featured full-screen views.</p>
<p>Developing in HTML5 and JavaScript is a different process from the familiar Java-based process for developing in the Niagara Framework. However, using the tools and techniques described in this document, you can create a JavaScript codebase that is robust, error-checked, and well-tested.</p>
<p><a name="frameworksAndLibraries"/></p>
<h1 id="frameworks-and-libraries">Frameworks and Libraries</h1>
<p>Before beginning HTML5 development in the Niagara Framework, you&rsquo;ll want to take a few moments to familiarize yourself with a few of the different libraries and frameworks available to you. These frameworks include <a href="module://docDeveloper/doc/jsdoc/bajaScript-ux/index.html">BajaScript</a>, <a href="module://docDeveloper/doc/jsdoc/bajaux-ux/index.html">bajaux</a>, and other <a href="module://docDeveloper/doc/index.html#openWeb">open web technologies</a>.</p>
<p><a name="settingUpYourEnvironment"/></p>
<h1 id="setting-up-your-environment">Setting Up Your Environment</h1>
<p>In order to most effectively develop Niagara web applications, you&rsquo;ll need to install a few external utilities for building, code analysis, and testing.</p>
<p>The toolchain described in this document is the one used by Tridium to develop all of its HTML5 web applications for Niagara 4. The tools described are free and open-source. The toolchain is separate from the Niagara Framework itself, so if you find that it does not suit your purposes, you are free to use a different set of development tools, or create your own.</p>
<p>To use the standard Tridium toolchain, you&rsquo;ll need to install the following utilities:</p>
<p><a name="nodeJs"/></p>
<h2 id="nodejs">Node.js</h2>
<p><a href="https://nodejs.org">Node.js</a> allows you to run JavaScript applications from the command line, without using a web browser. Tridium&rsquo;s open-source tools for developing Niagara web applications are all based upon Node.js.</p>
<p><a name="npm"/></p>
<h2 id="npm">npm</h2>
<p><code>npm</code> is a utility used to download and install Node.js modules. It is automatically installed alongside Node.js.</p>
<p><a name="grunt"/></p>
<h2 id="grunt">Grunt</h2>
<p><a href="http://gruntjs.com">Grunt</a> is a task runner for JavaScript. You will use it to find errors, run tests, and analyze your code. Install it like this:</p>
<pre><code>npm install -g grunt-cli
</code></pre>
<p>After that, you&rsquo;ll be able to run Grunt tasks for a web module by <code>cd</code>-ing into its directory and typing <code>grunt</code>.</p>
<p><a name="git"/></p>
<h2 id="git">Git</h2>
<p><a href="https://git-scm.com">Git</a> is used to clone entire repositories of source code to your machine. This is mostly used internally by <code>npm</code>, but you might also need to clone some repositories manually.</p>
<p><a name="environmentVariables"/></p>
<h2 id="environment-variables">Environment Variables</h2>
<p>These environment variables are necessary for doing Niagara web development. Some may already be set up for you - type <code>set</code> at your command line to see which are present.</p>
<ul>
  <li><code>niagara_home</code>: your Niagara runtime home directory, typically <code>c:\Niagara\Niagara-{versionNumber}</code>, which contains the <code>bin</code> folder.</li>
  <li><code>niagara_user_home</code>: directory containing your Niagara user files, notably the <code>stations</code> folder. Often, <code>%USERPROFILE%\Niagara4.x\{companyName}</code>.</li>
  <li><code>niagara_dev_home</code>: directory containing all your Niagara development files (source code, etc.). Instead of an environment variable, this value can also be set via the <code>niagara.dev.home</code> system property. This is a requirement for using <a href="#moduledevMode"><code>moduledev</code> mode</a>.</li>
</ul>
<p><a name="buildAndDevelopmentTools"/></p>
<h1 id="build-and-development-tools">Build and Development Tools</h1>
<p><a name="npmModules"/></p>
<h2 id="open-source-niagara-development-utilities">Open Source Niagara Development Utilities</h2>
<p>In order to properly build and test JavaScript modules, there is some setup involved. <code>npm</code> libraries need to be downloaded and installed, configuration files need to be written, and code needs to be moved into the proper directories.</p>
<p>We have created a number of utilities to make this process as easy as possible. These are open-source Node.js modules, created and released by <a href="https://github.com/tridium">Tridium</a>. They will facilitate a fully automated, test-driven approach to creating functional, reliable, well-tested Niagara web modules.</p>
<p><a name="grunt-init-niagara"/></p>
<h3 id="grunt-init-niagara">grunt-init-niagara</h3>
<p><code>grunt-init</code> is a tool that streamlines the creation of a new JavaScript project. The process is similar to Wizards you might use in Workbench: it asks you a number of setup questions and generates a brand-new web module for you to begin development.</p>
<p><code>grunt-init-niagara</code> is Tridium&rsquo;s own <code>grunt-init</code> template which is Niagara-specific; it generates you a brand-new Niagara web module that can be built and run using standard Niagara tools. The module will be pre-configured with source code and test directories, configuration files, and everything necessary to start developing.</p>
<p>All of the modules described in the rest of this section will be automatically included in your new module with no further configuration necessary. Simply type <code>npm install</code> to download everything, then begin development.</p>
<p>While it&rsquo;s entirely possible to create a new web module without using <code>grunt-init-niagara</code>, we highly recommend that you use it for your first web module to learn about the recommended project structure and configuration.</p>
<p><a name="grunt-niagara"/></p>
<h3 id="grunt-niagara">grunt-niagara</h3>
<p>This is less of a development tool and more of a collection of smart defaults. Including <code>grunt-niagara</code> in your project will include <a href="https://eslint.org/">ESLint</a>, <a href="http://karma-runner.github.io/">Karma</a>, <a href="https://github.com/es-analysis/plato">Plato</a>, and other development utilities, with configuration files pre-configured with settings Tridium has found to be optimal when developing web modules. The settings can be added to or changed in your own configuration files.</p>
<p>When creating a new module using <code>grunt-init-niagara</code>, you&rsquo;ll automatically have <code>grunt-niagara</code> installed and configured. For information about migrating an existing module to use <code>grunt-niagara</code>, see <a href="#migratingToGruntNiagara">Migrating to grunt-niagara</a>.</p>
<p><a name="niagara-station"/></p>
<h3 id="niagara-station">niagara-station</h3>
<p>This is a library that allows you to start and stop Niagara 4 stations using Node.js. It is most commonly used during the test process to start a station with BajaScript installed, so that the web module&rsquo;s unit tests can use a live BajaScript session to verify real-world behavior.</p>
<p>It also has some basic port configuration abilities. For example, if you are running tests on a machine that has port 80 already in use, <code>niagara-station</code> can reconfigure the station to run HTTP on port 8080 instead.</p>
<p>When using <code>grunt-init-niagara</code>, your web module will automatically receive a test station and a default <code>niagara-station</code> configuration.</p>
<p><a name="niagara-test-server"/></p>
<h3 id="niagara-test-server">niagara-test-server</h3>
<p>This module simply includes some utilities for logging into a running test station using JavaScript and triggering the browser to run tests. Again, it&rsquo;s automatically included by <code>grunt-init-niagara</code>.</p>
<p><a name="esLint"/></p>
<h2 id="eslint">ESLint</h2>
<p>Since JavaScript is an interpreted, not compiled, language, there is no compilation step to catch syntax errors before the code is run in the browser. This makes a static analysis tool like <a href="https://eslint.org/">ESLint</a> a necessity. It will find syntax errors (and some semantic errors as well) in your JavaScript code before it is run.</p>
<p>ESLint runs as a Grunt task as part of the standard development process.</p>
<p><a name="jasmine"/></p>
<h2 id="jasmine">Jasmine</h2>
<p><a href="http://jasmine.github.io">Jasmine</a> is Tridium&rsquo;s unit testing framework of choice. All of our JavaScript libraries, like BajaScript and bajaux, are fully unit tested using Jasmine.</p>
<p>The Jasmine framework will be automatically configured when using <code>grunt-niagara</code>. It is possible to use other testing frameworks, but you will need to configure these manually.</p>
<p><a name="karma"/></p>
<h2 id="karma">Karma</h2>
<p><a href="http://karma-runner.github.io">Karma</a> actually runs your tests and generates the results. By default, it will start up an instance of <a href="https://github.com/puppeteer/puppeteer">ChromeHeadless</a> - a headless Chromium instance - and run your full test suite. You can also connect any other browser to it, such as Firefox, Edge, or an iPhone, and run your tests in all of those browsers as well.</p>
<p>Note that if Chrome cannot be found for running tests, follow this <a href="https://github.com/tridium/grunt-niagara/tree/dev#karma">link</a> for additional information on this topic.</p>
<p><a name="niagaraRequireJSGradlePlugin"/></p>
<h2 id="building-and-compacting-your-javascript">Building and Compacting your JavaScript</h2>
<p>When building your web module, the build process can use the <a href="http://requirejs.org/docs/optimization.html">r.js optimizer</a> to compact all of your JavaScript code into a single file. Since network calls are the biggest factor affecting the loading time of your application, this is a crucial step in ensuring your app loads as quickly as possible.</p>
<p>This plugin also generates documentation for your app using JSDoc.</p>
<!--For more information, see the [Deploying Help](../deployingHelp.html) section.-->
<p><a name="moduledevMode"/></p>
<h2 id="developing-in-real-time-with-moduledev-mode">Developing in real time with <code>moduledev</code> mode</h2>
<p>When developing a web module, it&rsquo;s a severe slowdown to have to rebuild your module and restart your station every time you want to test out a new change in your browser. It&rsquo;s much faster to simply change a file and refresh the browser to pick up the latest changes.</p>
<p>To facilitate this, Niagara 4 includes a <code>moduledev</code> mode that allows files from certain modules to be read directly from your hard drive instead of from a module JAR file. In order to enable this mode, you&rsquo;ll need to perform the following steps.</p>
<p>First, you&rsquo;ll need to ensure this feature is enabled in your Tridium license. You&rsquo;ll need the <code>developer</code> feature included in your license with the <code>moduleDev</code> property set to <code>true</code>. If your license does not include this feature, please contact your Tridium sales representative.</p>
<p>Next, add an entry to <code>system.properties</code>: <code>niagara.module.dev=true</code>. This is for the browser only; for Workbench, there is another setting: <code>niagara.module.dev.wb=true</code>.</p>
<p>Not every file type can be resolved in this way: by default, only JS, CSS, HTML, image files, and some other web-related file types are supported. If you wish to resolve some different file types, you can configure this list using this system property: <code>niagara.module.dev.supportedExtensions=js,css,vm,htm(...)</code></p>
<p>Next, create a file <code>niagara_home/etc/moduledev.properties</code>. Each entry in this file maps a module name to the directory on your hard drive in which that module&rsquo;s source code lives. For instance, <code>myModule=d:/niagara/dev/myModule</code>. (Note that the runtime profile is not included! <code>myModule-ux=d:/niagara/dev/myModule/myModule-ux</code> will not work. <code>moduledev</code> mode will resolve files from any of your runtime profile directories.)</p>
<p>Now, whenever a request is made for a file, with a supported extension, from your web module, it will be resolved from your hard drive instead of from the JAR. This way, hitting refresh in the browser will always load your up-to-date changes. Note that this mode should <em>never</em> be enabled in production - only in development.</p>
<p><a name="firstSteps"/></p>
<h1 id="first-steps">First Steps</h1>
<p>Now that you&rsquo;ve set up your environment and gotten a brief introduction to the various JavaScript libraries and frameworks available to you, it&rsquo;s time to start developing! This section will contain a full tutorial, from creating your first module using <code>grunt-init-niagara</code>, to writing your first test, to viewing the result in the browser.</p>
<p><a name="creatingANewModule"/></p>
<h2 id="creating-a-new-module">Creating a new module</h2>
<p>Begin by installing <a href="https://github.com/tridium/grunt-init-niagara"><code>grunt-init-niagara</code></a> to your machine, following the instructions from <a href="http://gruntjs.com/project-scaffolding">the Grunt website</a>. This process may vary from machine to machine, but will probably look similar to:</p>
<pre><code>npm install -g grunt-init
mkdir %USERPROFILE%/.grunt-init
cd %USERPROFILE%/.grunt-init
git clone https://github.com/tridium/grunt-init-niagara
</code></pre>
<p>Once installed, navigate in a console to your dev directory containing the source for your Niagara modules. If you have not set up a build environment using the New Module Wizard, do so using the steps <a href="../build.html">here</a> first.</p>
<p>The steps below assume you are working with a typical multi-module Gradle setup rooted at <code>%niagara_user_home%</code>. As usual, any Gradle commands should only be run from the root of your build (the same folder containing <code>build.gradle</code> and <code>settings.gradle</code>).</p>
<p>Begin the process like so:</p>
<pre><code>mkdir myWebModule
cd myWebModule/
grunt-init grunt-init-niagara
</code></pre>
<p>Note that if you are adding a -ux part to an existing module, or if you specified -ux as a module part when running the New Module Wizard, you will need to run grunt-init with the <code>--force</code> option. <code>grunt-init</code> will not run by default if there are existing files in your directory - it doesn&rsquo;t want to overwrite them!</p>
<p>You&rsquo;ll be asked a series of questions. Leaving the answer to any question blank will accept the default (shown in parentheses). For this tutorial, we&rsquo;ll ask it to create a bajaux Widget for us to study and modify.</p>
<pre><code>Please answer the following:
[?] Niagara module name (myWebModule)
[?] What Niagara version will you build your module against? (4.10)
[?] Shortened preferred symbol for your Niagara module (myWbMdl)
[?] Description of your Niagara module My First Web Module
[?] Author name (myCompany)
[?] Would you like to create a bajaux Widget? (y/N) y
</code></pre>
<p>After completing all the questions (you can select default values for all additional questions not shown above), it will generate a <code>myWebModule-ux</code> directory, containing the generated sources for your web module. It should build and install using the normal build process:</p>
<pre><code>gradlew :myWebModule-ux:jar :myWebModule-ux:moduleTestJar
</code></pre>
<p>(To facilitate rapid development, ensure that you have enabled <a href="#moduledevMode"><code>moduledev</code> mode</a> and added an entry for <code>myWebModule</code> to <code>moduledev.properties</code> at this time.)</p>
<p>Just to make sure everything is functional, let&rsquo;s install and run tests for our module.</p>
<pre><code>cd myWebModule-ux/
grunt ci
</code></pre>
<p>Don&rsquo;t worry, I&rsquo;ll describe what&rsquo;s happening in just a moment. <code>gradlew jar</code> should download and install all the necessary dependencies to run tests for your module, then <code>grunt ci</code> should actually run those tests. Hopefully, you&rsquo;ll see <code>SUCCESS</code> at the end of this process. Now let&rsquo;s take a look at a few of the individual steps in this process, and the relevant configuration files.</p>
<p><a name="packageJson"/></p>
<h3 id="packagejson">package.json</h3>
<p>This file is used by Node.js and <code>npm</code>. Most of it won&rsquo;t be relevant to you unless you decide to publish your module to the <a href="https://www.npmjs.com">npm repository</a>. The important part is the <code>devDependencies</code> section, which describes which additional modules your module depends on. It will be pre-populated with those modules that are necessary to run unit tests for your Niagara web module.</p>
<p>Typing <code>npm install</code> will download these dependencies from <code>npm</code> and install them for you. But <code>gradlew jar</code> will do this for you as part of the build process you completed in the last step, so you shouldn&rsquo;t need to do it a second time.</p>
<p><a name="gruntfileJs"/></p>
<h3 id="gruntfilejs">Gruntfile.js</h3>
<p>This file is used by Grunt. It describes all the automated tasks that are available for your module, and sets up configuration settings for each.</p>
<p>You will see at the bottom of the file that it loads tasks for the <code>grunt-niagara</code> module. This is a utility module that includes tasks that we at Tridium have found to be very useful when developing web applications. It sets up a default configuration for each one that we find to work well. You are free to override these configurations as you wish, but just leaving this file alone and working with the provided config is a great way to get started. (Later on, if you decide that <code>grunt-niagara</code> isn&rsquo;t right for you, you can leave it out completely and build your own toolchain as you see fit.)</p>
<p>To see the tasks that are available to you right out of the box, just type <code>grunt</code>.</p>
<p>Another feature that <code>grunt-niagara</code> provides for you is the ability to pass in config flags on the command line when running tests. To see a list of all available flags, type <code>grunt flags</code>. A few flags you may find particularly useful are:</p>
<ul>
  <li><code>--testOnly</code>: if your test suite grows large, you may find it taking longer and longer to run all of your specs. You can use <code>testOnly</code> to limit which specs are run.</li>
  <li><code>--station-http-port</code>: if your test station runs a different HTTP port, you can specify which port your tests should use to attempt to log into the station. There are also corresponding flags for HTTPS, FOX, and FOXS.</li>
  <li><code>--override-station-ports</code>: used in conjunction with the previous flags, actually will inject the port number into the <code>config.bog</code> before starting the station to force it to run on a particular port. This is helpful if one of the default ports is already in use on your machine.</li>
  <li><code>--station-log-level</code>: configure how much detail from the station log is output to the console when running tests. It defaults to NONE because usually you&rsquo;ll only want to see the actual test output instead of a lot of noise from the station. But dialing it up to INFO, FINE, or all the way to ALL can help with debugging.</li>
</ul>
<p>Many of these flags&rsquo; default values are set using the <code>niagara_home</code> and <code>niagara_user_home</code> environment variables.</p>
<p><a name="watching"/></p>
<h2 id="watching-the-important-stuff">Watching - The Important Stuff</h2>
<p>Let&rsquo;s start developing straight away by typing <code>grunt watch</code>. Your test station will be copied into your <code>stations/</code> directory and started up (note that the default credentials for the test station are user: <code>admin</code>, password: <code>asdf1234</code>), and an instance of Karma will be started as well. By default, a single instance of <a href="https://github.com/puppeteer/puppeteer">ChromeHeadless</a> - a command-line, headless web browser - will start and get ready to run tests. (If you wish to run tests in other browsers, like Firefox or Edge, it will print out instructions on how to connect those as well.)</p>
<p>What happens now is that every time you save a change to a file, the <code>grunt watch</code> task will immediately spring into action, running ESLint to detect syntax errors and other bugs, and then running your suite of tests in Karma to verify behavior. This allows for a very rapid TDD, red-green-refactor workflow.</p>
<p>Let&rsquo;s demonstrate the process. <code>grunt-init-niagara</code> should have generated you a file called <code>MyWebModuleWidget.js</code>. Out of the box, the code should pass all linting and tests, so we&rsquo;ll have to introduce some new errors to see how they are handled. Take a look at the <code>doLoad</code> (or the spandrel function if you generated JSX) function, and you should see a line that looks like this:</p>
<pre><code class="sunlight-highlight-javascript">that.$buildButtons(value);
</code></pre>
<p>Change it so that it looks like this:</p>
<pre><code class="sunlight-highlight-javascript">that.$buildButtons(schmalue)
</code></pre>
<p>Now save the file. Grunt should detect your change and immediately go to work. After running tests, the next step in the watch process is to run <a href="https://eslint.org/">ESLint</a> on your code. Ignoring test failures for now: our change introduced two errors in our code, and ESLint should have caught them both:</p>
<pre><code>&gt;&gt; File &quot;src\rc\MyWebModuleWidget.js&quot; changed.
Running &quot;eslint:src&quot; (eslint) task

   src\rc\MyWebModuleWidget.js
    118 |    that.$buildButtons(schmalue)
                                      ^ Missing semicolon.
    118 |    that.$buildButtons(schmalue)
                                ^ 'schmalue' is not defined.
</code></pre>
<p>If you generated JSX, you can try the same thing in the spandrel function: Find the line that looks like this:</p>
<pre><code class="sunlight-highlight-javascript">{ comp.getDisplayName(slot) }
</code></pre>
<p>Change it so that it looks like this:</p>
<pre><code class="sunlight-highlight-javascript">{ komp.getDisplayName(slot) }
</code></pre>
<p>You will see a similar &lsquo;komp is not defined&rsquo; ESLint error.</p>
<p>As you can see, whenever you introduce an error that ESLint can detect, you will be alerted. Note that ESLint is a static code analysis tool; it is separate from actually running your code during the test phase. ESLint looks for syntax errors, misspellings, code style problems, and similar categories of errors. It will not find logical errors in the execution of your code. That happens in the testing phase.</p>
<p>Back out the change we just made so that it looks like it did before:</p>
<pre><code class="sunlight-highlight-javascript">that.$buildButtons(value);
</code></pre>
<p>Now, we&rsquo;ll take a closer look at the unit testing capabilities of Karma. We&rsquo;re going to follow the traditional TDD method of red-green-refactor:</p>
<ol>
  <li>Write a new unit test and run it. It will fail, because you haven&rsquo;t yet written the code to make it pass. Unit tests should be small and focused. This is called the &ldquo;red&rdquo; phase because test failures usually are shown in red.</li>
  <li>Write the bare minimum amount of code to implement the behavior that the test is verifying, then run it again. It should pass. This is called the &ldquo;green&rdquo; phase because test successes usually are shown in green. You should never write production code without first having already written a failing test for it.</li>
  <li>Once you have good test coverage by following steps 1 and 2 many times, you can refactor your code for greater readability and efficiency, without worrying about breaking old behavior. Just make sure that your refactoring doesn&rsquo;t introduce new behavior without accounting for it in the unit tests.</li>
</ol>
<p>Take a look at the example page at <a href="http://localhost/module/myWebModule/rc/myWebModule.htm">http://localhost/module/myWebModule/rc/myWebModule.htm</a> that <code>grunt-init-niagara</code> generated for us (remember that the default credentials for the test station are user: <code>admin</code>, password: <code>asdf1234</code>). You&rsquo;ll see that it creates a clickable button for every slot on a <code>Component</code>, and whenever we click one of the buttons, it updates to show the name of the slot we selected. For this next example, we want to change the widget&rsquo;s behavior slightly. Instead of just displaying the slot name, we&rsquo;ll add an exclamation mark just to properly convey our excitement.</p>
<p>The first step is to change the test. (If we were adding new behavior to the widget we&rsquo;d add another test, but since we&rsquo;re changing existing behavior, we can just change the test.) Take a look at <code>srcTest/rc/MyWebModuleWidgetSpec.js</code>. This suite of unit tests is written using the <a href="http://jasmine.github.io/">Jasmine</a> framework, which is Tridium&rsquo;s test framework of choice and the one automatically configured by <code>grunt-niagara</code>.</p>
<p>Look at the spec named <code>arms a handler to display selected slot name</code>. Since we&rsquo;re changing the way the slot name is displayed, this is also the spec that we will change. Towards the bottom of the spec, you will see the verification test that looks something like this:</p>
<pre><code class="sunlight-highlight-javascript">waitForTrue(() =&gt; slotDom.text() === 'larry');
</code></pre>
<p>Change it so that it&rsquo;s expecting an exclamation point:</p>
<pre><code class="sunlight-highlight-javascript">waitForTrue(() =&gt; slotDom.text() === 'larry!');
</code></pre>
<p>Save the file. Since <code>grunt watch</code> is running, the change will be immediately detected and your test suite will be run. You should see the spec fail:</p>
<pre><code>nmodule/myWebModule/rc/MyWebModuleWidget #doInitialize() arms a handler to display selected slot name FAILED
        Expected { message : 'timed out after 5000 msec waiting for something to happen', stack : 
        'Error: timed out after 5000 msec waiting for slot name to match the expected name.
Executed 8 of 8 (1 FAILED) (0.562 secs / 0.567 secs)
</code></pre>
<p>This is the &ldquo;red&rdquo; phase of development: we have a failing unit test. By first having a failing test, we get visual proof that the behavior we&rsquo;re writing has correct test coverage behind it. To get back to green, we go into <code>src/rc/MyWebModuleWidget.js</code> and update the <code>$updateSlotText</code> function to add the exclamation point we need:</p>
<pre><code class="sunlight-highlight-javascript">that.jq().find('.MyWebModuleWidget-selected-slot').text(slotName + '!');
</code></pre>
<p>Save the file and the test will automatically be run. This time, everything should pass.</p>
<p>Using these frameworks and techniques, you have the ability to implement a fully test-driven development process from beginning to end. It may seem like a large upfront time investment (isn&rsquo;t it twice as much code for the same functionality?) but a comprehensive suite of automated tests for your code is invaluable: short-term, it helps to ensure that the code you write actually does what you think it does; and long-term, it allows you to make changes, improvements, and refactorings to your code without worrying about breaking existing functionality.</p>
<p><a name="aNoteOnContinuousIntegration"/></p>
<h2 id="a-note-on-continuous-integration">A note on Continuous Integration</h2>
<p>Unit tests, as configured by <code>grunt-niagara</code>, will export their results in a JUnit-compatible XML format. This means that if your organization uses a Continuous Integration solution, like Bamboo or Jenkins, it can consume these XML files. Your JavaScript code can then be included in your CI process.</p>
<p>When invoking the Grunt process, use <code>grunt ci</code> to run CI-related tasks and generate these XML files. If needed, you can use the <code>--junit-reports-dir</code> flag to specify where the XML results go.</p>
<p><a name="buildingYourJavaScriptIntoANiagaraModule"/></p>
<h1 id="building-your-javascript-into-a-niagara-module">Building your JavaScript into a Niagara module</h1>
<p>Implementing your JavaScript-based widgets is only one part of the development process. They must also be built into your Niagara module so that they can be deployed to Niagara stations and supervisors.</p>
<h2 id="specifying-additional-grunt-tasks">Specifying additional Grunt tasks</h2>
<p><a name="specifyingAdditionalGruntTasks"/></p>
<p>By default, the Niagara build environment will run any Grunt tasks you have configured (the default is just the <code>requirejs</code> task) prior to building the module jar. You can change this by editing the &ldquo;gruntBuild&rdquo; section of your module&rsquo;s Gradle build file:</p>
<pre><code>gruntBuild { tasks 'requirejs' }
</code></pre>
<p>You may add additional tasks by specifying the task name(s) as such:</p>
<pre><code>gruntBuild { tasks 'less', 'babel', 'requirejs' }
</code></pre>
<p>You can then build your module as normal:</p>
<pre><code>gradlew :myWebModule-ux:jar
</code></pre>
<p><a name="compactingUsingTheGradleRequireJSPlugin"/></p>
<h2 id="compacting-using-the-grunt-requirejs-plugin">Compacting using the Grunt RequireJS Plugin</h2>
<p>One of the tasks available for the <code>gruntBuild</code> config is <code>requirejs</code>. This Grunt task will optimize your JavaScript using <a href="http://requirejs.org/docs/optimization.html">r.js</a>. All JavaScript modules will have all of their dependencies resolved and included in a single file: <code>myWebModule.built.min.js</code>. This allows you to download every JavaScript file in your Niagara module using a single network call. This is crucial on embedded devices where negotiating network connections can be slow.</p>
<p><a name="implementingBIJavaScript"/></p>
<h2 id="implementing-bijavascript">Implementing BIJavaScript</h2>
<p>Often, your HTML5 web app will have an instance of some BajaScript value: a <code>Facets</code>, for instance, or a <code>DynamicEnum</code>, that you wish to present to the user in an editor. You could manually go and fetch the code for <code>FacetsEditor</code> or <code>DynamicEnumEditor</code>, then instantiate, initialize, and load it into your page. It would be much easier, though, to simply ask the framework for an editor that&rsquo;s appropriate to edit that value. Then, you&rsquo;ll be certain that you&rsquo;ll be provided the correct, most up-to-date version of that editor.</p>
<p>Also, consider the Property Sheet. If you have a custom Baja value and a custom field editor to edit that value, you&rsquo;ll need to create an association between the two so the Property Sheet knows how to show the correct editor for your custom value.</p>
<p>The way to do this is to create a simple Java class in your module. Its only job is to provide answers to these questions:</p>
<ol>
  <li>What JavaScript file represents the implementation of my editor?</li>
  <li>What Types can I edit with this editor?</li>
</ol>
<p><a name="whatJavaScriptFileDefinesMyEditor"/></p>
<h3 id="what-javascript-file-defines-my-editor">What JavaScript file defines my editor?</h3>
<p>To let the Niagara framework know about the JavaScript file containing your editor, create a Java class that extends <code>BSingleton</code> and implements <code>javax.baja.web.js.BIJavaScript</code>. This simply creates a mapping between a Niagara Type and a JavaScript file.</p>
<pre><code class="sunlight-highlight-java">@NiagaraType
@NiagaraSingleton
public final class BMyWebModuleWidget
  extends BSingleton
  implements BIJavaScript, BIFormFactorMini, BIOffline
{
  private BMyWebModuleWidget() {}

  public JsInfo getJsInfo(Context cx) { return JS_INFO; }

  private static final JsInfo JS_INFO = JsInfo.make(
    BOrd.make(&quot;module://myWebModule/rc/MyWebModuleWidget.js&quot;),
    BMyWebModuleJsBuild.TYPE
  );
}
</code></pre>
<p>As you can see, there is very little to a <code>BIJavaScript</code> class. It has only one method to implement, <code>getJsInfo()</code>, which lets the Niagara Framework know where the JavaScript implementation of your widget is located.</p>
<p>Also notice the implemented interface <code>BIFormFactorMini</code> - see the <a href="module://docDeveloper/doc/index.html#bajaux">bajaux</a> documentation for details on what this does.</p>
<p>(Beginning in Niagara 4.2, BajaScript supports offline editing of .bog files. If you are implementing a field editor that you wish to be available offline, also implement the marker interface <code>BIOffline</code>. Note that a number of operations are unavailable while BajaScript is in offline mode, such as resolving station-specific ORDs and making XMLHttpRequests, so ensure that your field editor will not attempt to perform unsupported operations before implementing <code>BIOffline</code>.)</p>
<p>You can also see as part of the <code>JsInfo.make()</code> method, you can pass in an instance of <code>BJsBuild</code>. This performs a very similar function to <code>BIJavaScript</code>, but instead of providing the location of a single JavaScript module, it provides the location of an optimized JavaScript built file: e.g., <code>myWebModule.built.min.js</code> produced by the Gradle RequireJS plugin as described above.</p>
<p>The implementation of a <code>BJsBuild</code> class is also very simple:</p>
<pre><code class="sunlight-highlight-java">public class BMyWebModuleJsBuild extends BJsBuild
{
  public static final BMyWebModuleJsBuild INSTANCE = new BMyWebModuleJsBuild(
    &quot;myWebModule&quot;, //webdev ID
    new BOrd[] {
      BOrd.make(&quot;module://myWebModule/rc/myWebModule.built.min.js&quot;)
    }
  );

  //TYPE and private constructor
}
</code></pre>
<p>While optimizing your JavaScript and creating <code>BJsBuild</code> classes are strictly optional, they are highly recommended.</p>
<p>Don&rsquo;t forget that your <code>BIJavaScript</code> and <code>BJsBuild</code> classes are standard Niagara Types and should be included in <code>module-include.xml</code>.</p>
<p><a name="whatTypesCanIEditWithMyEditor"/></p>
<h3 id="what-types-can-i-edit-with-my-editor">What Types can I edit with my editor?</h3>
<p>Now that you&rsquo;ve implemented a JavaScript editor and registered its existence with the framework, you can also declare it to be compatible with certain Types. For instance, <code>MyWebModuleWidget</code> might be able to load values of type <code>myWebModule:MyWebModuleComponent</code>. To declare this relationship, simply register your <code>BIJavaScript</code> as an agent on a Type. You can do this the usual way, in <code>module-include.xml</code>:</p>
<pre><code class="sunlight-highlight-xml">&lt;type name=&quot;MyWebModuleWidget&quot; class=&quot;com.tridium.mywebmodule.BMyWebModuleWidget&quot;&gt;
  &lt;agent&gt;&lt;on type=&quot;myWebModule:MyWebModuleComponent&quot; /&gt;&lt;/agent&gt;
&lt;/type&gt;
</code></pre>
<p>Or (recommended) the new annotation-based method available in Niagara 4:</p>
<pre><code class="sunlight-highlight-java">@NiagaraType(agent = @AgentOn(types = { &quot;myWebModule:MyWebModuleComponent&quot; }))
public final class BMyWebModuleWidget
</code></pre>
<p><a name="webdevMode"/></p>
<h2 id="switching-your-station-into-web-development-mode">Switching your Station into Web Development mode</h2>
<p>One last thing to consider. At this point you have two files containing your editor&rsquo;s code: the one you&rsquo;ve just created, with the human-readable JavaScript code (<code>MyWebModuleWidget.js</code>), and the built and minified version for conserving network traffic (<code>myWebModule.built.min.js</code>).</p>
<p>During normal usage, your station will only serve up the minified file. This is absolutely the correct behavior: on an embedded device, conservation of network traffic is key. But take a look at the minified file: it&rsquo;s completely incomprehensible. When developing and debugging, you really want to be able to see the original, human-readable code.</p>
<p>By enabling <code>webdev</code> mode for your module, the station will kick into debug mode: it will switch over to serving up the original file, so that you can open up the console in Chrome or Internet Explorer and trace through your actual code.</p>
<p>To enable <code>webdev</code> mode, simply go into the spy page for the station and visit the <code>webDevSetup</code> page. (You&rsquo;ll need to actually visit the web interface first - so the station serves up some files - for it to appear.) Enable <code>webdev</code> mode for the ID of your <code>BJsBuild</code>, and from then on, the unminified files from your module will be served to the browser. This is invaluable when debugging your code live in the browser. (To learn more about browser debugging, search the web for &ldquo;{your browser name} console tutorial.&rdquo;)</p>
<p>You can also configure <code>webdev</code> by hand by editing <code>%niagara_user_home%/etc/webdev.properties</code>.</p>
<p><a name="movingForward"/></p>
<h1 id="moving-forward">Moving Forward</h1>
<p>Let&rsquo;s do a quick recap of what you&rsquo;ve accomplished so far.</p>
<ol>
  <li>You&rsquo;ve created a widget with JavaScript that can be used in the new Niagara 4 HTML5 web views (<code>MyWebModuleWidget.js</code>)</li>
  <li>You&rsquo;ve registered its existence with the framework (<code>BMyWebModuleWidget</code> implements <code>BIJavaScript</code>)</li>
  <li>You&rsquo;ve optimized it down within a single built JavaScript file to minimize network traffic (<code>requirejs</code> configuration creates <code>myWebModule.built.min.js</code>)</li>
  <li>You&rsquo;ve registered the existence of the built file with the framework (<code>BMyWebModuleJsBuild</code> extends <code>BJsBuild</code>) and let the framework know that your widget&rsquo;s code is packaged within it (<code>BMyWebModuleWidget</code> references <code>BMyWebModuleJsBuild</code>)</li>
  <li>You&rsquo;ve let the framework know to show you a <code>MyWebModuleWidget</code> when it tries to load an editor for a compatible Type (<code>BMyWebModuleWidget</code> is an Agent on <code>BMyWebModuleComponent</code>).</li>
</ol>
<p>At this point, you have everything you need to go full-speed into developing HTML5 widgets and editors. Continue using the linting and testing tools provided by <code>grunt-init-niagara</code> to iterate over your widget until it is well tested, error-checked, and fully functional. (If you are developing a field editor intended for use in the HTML5 Property Sheet, definitely check out the <a href="module://docDeveloper/doc/jsdoc/webEditors-ux/index.html">webEditors tutorial</a> for notes on this use case.)</p>
<p>Feel free to stop by the Niagara Central Forums to discuss any questions or problems.</p>
<p>Happy coding!</p>
<p><a name="appendix"/></p>
<h1 id="appendix">Appendix</h1>
<p><a name="migratingToGruntNiagara"/></p>
<h2 id="migrating-from-niagara-rjs-to-grunt-niagara">Migrating from <code>niagara-rjs</code> to <code>grunt-niagara</code></h2>
<p>When using <code>grunt-init-niagara</code> to create a new Niagara module targeting 4.6 or later, <code>grunt-niagara</code> will automatically be used in place of <code>niagara-rjs</code>. When migrating an existing module to the latest version of Niagara, the <code>niagara-rjs</code> config should be removed and migrated to use <code>grunt-niagara</code> instead. This section will describe that migration process.</p>
<h3 id="creating-gruntfilejs-and-packagejson">Creating Gruntfile.js and package.json</h3>
<p>One option is to run <code>grunt-init-niagara</code> in an empty directory, which will generate a <code>Gruntfile</code> and <code>package.json</code> for you. Or, for an existing module, you can manually create them as shown below. Both of these files go in the root of your module part, that is, <code>yourModuleName/yourModuleName-ux</code>.</p>
<pre><code>//package.json
{
  &quot;name&quot;: &quot;yourModuleName-ux&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.0.0&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.0.0&quot;,
    &quot;babel-plugin-istanbul&quot;: &quot;^4.1.3&quot;,
    &quot;grunt&quot;: &quot;~1.0.1&quot;,
    &quot;grunt-niagara&quot;: &quot;^2.1.0&quot;
  }
}
 
 
//Gruntfile.js
const SRC_FILES = [
  'src/rc/**/*.js',
  '!src/rc/**/*.min.js'
];
const TEST_FILES = [
  'srcTest/rc/**/*.js'
];
const ALL_FILES = SRC_FILES.concat(TEST_FILES);
 
module.exports = function runGrunt(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),
 
    jsdoc:     { src: SRC_FILES },
    eslint:    { src: ALL_FILES },
    watch:     { src: ALL_FILES },
    karma:     {},
    babel:     {},
    requirejs: {},
    niagara:   {
      station: {
        forceCopy: true,
        sourceStationFolder: './srcTest/stations/bajauxUnitTest'
      }
    }
  });
 
  grunt.loadNpmTasks('grunt-niagara');
};
</code></pre>
<h3 id="configuring-requirejs">Configuring RequireJS</h3>
<p>Let&rsquo;s look at an example <code>niagaraRjs</code> config block from a legacy Gradle file.</p>
<pre><code>//in myModule-ux.gradle:
niagaraRjs {
  builds = [
    'myDefaultBuild': [
      rootDir: 'src/rc',
      include: [
        'nmodule/myModule/rc/fe/MyWidget',
        'nmodule/myModule/rc/fe/YourWidget',
        // ... every file in my module
      ]
    ]
  ]
 
  options = [
    disablePlugins: [ 'baja', 'lex', 'css' ],
    exclude: [ 'Handlebars', 'underscore', 'hbs' ],
    hbs: [
      disableHelpers: true,
      disableI18n: true
    ],
 
    paths: [
      'nmodule': 'empty:',
      'bajaScript': 'empty:',
      'jquery': 'empty:',
      'bajaux': 'empty:',
      'dialogs': 'empty:',
      'profileInfo': 'empty:',
      'bajauxContainer': 'empty:',
      'jqueryContextMenu': 'empty:',
      'hx': 'empty:',
      'Promise': 'empty:',
      'ace': 'empty:',
 
      'nmodule/myModule': 'src',
      'nmodule/myModuleTest': 'srcTest',
 
      'Handlebars': projectResource('js-ux', 'rc/handlebars/handlebars-v2.0.0'),
      'hbs': projectResource('js-ux', 'rc/require-handlebars-plugin/hbs'),
      'i18nprecompile': projectResource('js-ux', 'rc/require-handlebars-plugin/hbs/i18nprecompile'),
      'json2': projectResource('js-ux', 'rc/require-handlebars-plugin/hbs/json2'),
      'underscore': projectResource('js-ux', 'rc/underscore/underscore')
    ],
    rhinoJvmArgs: [ '-Xss4m' ]
  ]
}
</code></pre>
<p>The <code>grunt-niagara</code> equivalent of this configuration is:</p>
<pre><code>// in myModule-ux.gradle:
apply plugin: &quot;com.tridium.niagara-grunt&quot;
gruntBuild { tasks 'requirejs' }
 
// in Gruntfile.js:
requirejs: {}
</code></pre>
<p>That&rsquo;s it! By including an empty <code>requirejs</code> block, RequireJS optimization will be turned on, using the default behavior. The default behavior of <code>grunt-niagara</code> matches the existing behavior of <code>niagara-rjs</code> and is described below:</p>
<ul>
  <li>Automatically include every <code>.js</code> file in <code>src/rc</code> into the builtfile</li>
  <li>Place the builtfile at <code>build/src/rc/yourModuleName.built.min.js</code>, where it will be packaged into the .jar</li>
  <li>Disable the appropriate plugins (for instance, you cannot actually use the <code>baja!</code> plugin to start up a BajaScript session while optimizing)</li>
  <li>Omit the most commonly used libraries from other modules, to prevent them from being unnecessarily duplicated in your builtfile</li>
  <li>Use <code>require-handlebars-plugin</code> to package Handlebars templates into the builtfile</li>
</ul>
<p>Most of the customization for the <code>requirejs</code> task in grunt-niagara is identical to the customization for <code>niagara-rjs</code>, just converted from Groovy to JavaScript. Any customization you provide will be merged in with the defaults, so you do not need to customize every single rule, only the ones that differ from the default. All configuration options supported by <a href="https://github.com/gruntjs/grunt-contrib-requirejs">grunt-contrib-requirejs</a> are supported in <code>grunt-niagara</code>.</p>
<p>One thing that differs is that <code>projectResource</code> is no longer available because <code>grunt-niagara</code> runs outside the scope of any Gradle project. Instead, use <code>moduleResources</code> as shown:</p>
<pre><code>// moduleResources allows resources from other Niagara modules to be
// included in your builtfile. usually, you would want them to be
// excluded using an 'empty:' path to avoid code duplication. but if
// you want to avoid the dependency on the other module, you can build
// it in to avoid the additional download.
// note that this requires moduledev.properties to be configured to see
// the source directory of the source module. see above for more info on
// moduledev mode.
requirejs: {
  options: {
    moduleResources: {
      'underscore': 'nmodule/js/rc/underscore/underscore.min'
    }
  }
}
</code></pre>

<script type='text/javascript'>window.niagara.docDevUtil.highlightCode();</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/build.html" class="navbar">Prev</a> |  <a href="/doc/slot-o-matic.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
