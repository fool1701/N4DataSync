<?xml version="1.0" encoding="UTF-8"?>
<bajadoc version="2.0" createdBy="niagara-baja-doclet-1.0.9" createdAt="03-May-2024" createdOn="883e7f7a9875">
<class module="baja" runtimeProfile="rt" qualifiedName="javax.baja.query.BQueryScheme" name="BQueryScheme" packageName="javax.baja.query" public="true" abstract="true">
<description>
A BQueryScheme is an ord scheme whose body is a query syntax and when resolved, processes&#xa;  the query against a Niagara space.
</description>
<tag name="@author">John Sublett</tag>
<tag name="@creation">01/15/2014</tag>
<tag name="@since">Niagara 4.0</tag>
<extends>
<type class="javax.baja.naming.BOrdScheme"/>
</extends>
<!-- javax.baja.query.BQueryScheme(java.lang.String) -->
<constructor name="BQueryScheme" protected="true">
<parameter name="id">
<type class="java.lang.String"/>
</parameter>
<description>
Create a BOrdScheme with the specified ID.
</description>
</constructor>

<!-- javax.baja.query.BQueryScheme.getType() -->
<method name="getType"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.sys.Type"/>
</return>
</method>

<!-- javax.baja.query.BQueryScheme.resolve(javax.baja.naming.OrdTarget, javax.baja.naming.OrdQuery) -->
<method name="resolve"  public="true">
<description/>
<parameter name="base">
<type class="javax.baja.naming.OrdTarget"/>
</parameter>
<parameter name="query">
<type class="javax.baja.naming.OrdQuery"/>
</parameter>
<return>
<type class="javax.baja.naming.OrdTarget"/>
</return>
<throws>
<type class="javax.baja.naming.SyntaxException"/>
</throws>
<throws>
<type class="javax.baja.naming.UnresolvedException"/>
</throws>
</method>

<!-- javax.baja.query.BQueryScheme.findQueryHandler(javax.baja.naming.OrdTarget, javax.baja.query.BQueryScheme) -->
<method name="findQueryHandler"  public="true" static="true">
<description>
Find a query handler for the specified scope and scheme.
</description>
<parameter name="scope">
<type class="javax.baja.naming.OrdTarget"/>
<description>
The collection of objects that the query will be evaluated against.
</description>
</parameter>
<parameter name="queryScheme">
<type class="javax.baja.query.BQueryScheme"/>
<description>
The scheme for the query to be evaluated.
</description>
</parameter>
<return>
<type class="javax.baja.query.BIQueryHandler"/>
<description>
Returns a BIQueryHandler or null if no handler can be found.
</description>
</return>
</method>

<!-- javax.baja.query.BQueryScheme.registerPriorityQueryHandler(javax.baja.query.BIQueryHandler, int) -->
<method name="registerPriorityQueryHandler"  public="true" static="true">
<description>
Register the given BIQueryHandler instance to be considered during query ord resolution.
</description>
<tag name="@since">Niagara 4.4</tag>
<parameter name="handler">
<type class="javax.baja.query.BIQueryHandler"/>
<description>
The BIQueryHandler instance to register
</description>
</parameter>
<parameter name="priority">
<type class="int"/>
<description>
The priority level to use for the given priority query handler. Priority query&#xa;                 handlers give precedence to the lowest priority level. At query resolution time,&#xa;                 the priority query handler with the lowest priority level that can handle the&#xa;                 query will win.
</description>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.query.BQueryScheme.unregisterPriorityQueryHandler(javax.baja.query.BIQueryHandler) -->
<method name="unregisterPriorityQueryHandler"  public="true" static="true">
<description>
Unregister the given BIQueryHandler instance from the priority handler list
</description>
<tag name="@since">Niagara 4.4</tag>
<parameter name="handler">
<type class="javax.baja.query.BIQueryHandler"/>
<description>
The BIQueryHandler instance to unregister
</description>
</parameter>
<return>
<type class="boolean"/>
<description>
true if the instance was in the list and successfully unregistered
</description>
</return>
</method>

<!-- javax.baja.query.BQueryScheme.postInit() -->
<method name="postInit"  public="true" static="true">
<description>
For framework use only
</description>
<tag name="@since">Niagara 4.4</tag>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.query.BQueryScheme.TYPE -->
<field name="TYPE"  public="true" static="true" final="true">
<type class="javax.baja.sys.Type"/>
<description/>
</field>

<!-- javax.baja.query.BQueryScheme.QUERY_LIMIT_FACET_KEY -->
<field name="QUERY_LIMIT_FACET_KEY"  public="true" static="true" final="true">
<type class="java.lang.String"/>
<description>
This facet key name can be optionally checked when resolving a query to enforce a limit&#xa; on the number of results.  Implementations of BIQueryHandler may or may not check for this&#xa; limit in the Context facets, so callers are not guaranteed to get back a limited set of&#xa; results.  Instead, this can be used to request a limit on the number of results, and if the&#xa; backend implementation of the BIQueryHandler supports limiting the results returned, it will&#xa; do so if a Context facet is set with this facet key and a positive BInteger value indicating&#xa; the maximum requested results to return for the processed query. A zero (or negative) BInteger&#xa; value paired with this facet key also means that no limit is requested.
</description>
<tag name="@since">Niagara 4.7</tag>
</field>

<!-- javax.baja.query.BQueryScheme.ALTERNATE_SCOPE_FACET_KEY -->
<field name="ALTERNATE_SCOPE_FACET_KEY"  public="true" static="true" final="true">
<type class="java.lang.String"/>
<description>
This facet key name will be checked on the base OrdTarget when resolving a&#xa; query to see if an alternate query scope should be used instead of the base when&#xa; resolving the query. If the &lt;code&gt;<see ref="javax.baja.query.BQueryScheme#MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY">#MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY</see>&lt;/code&gt; facet is also&#xa; set to a value of &lt;code&gt;<see ref="javax.baja.sys.BBoolean#TRUE">BBoolean#TRUE</see>&lt;/code&gt;, then a new Entity is created with an entity ORD&#xa; matching that specified by this facet&#x27;s value to be used as the alternate scope of the query.&#xa; If the &lt;code&gt;<see ref="javax.baja.query.BQueryScheme#MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY">#MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY</see>&lt;/code&gt; facet is not present or not set to a&#xa; value of &lt;code&gt;<see ref="javax.baja.sys.BBoolean#TRUE">BBoolean#TRUE</see>&lt;/code&gt;, then this alternate query scope will be resolved just prior to&#xa; processing the query.
</description>
<tag name="@since">Niagara 4.6</tag>
</field>

<!-- javax.baja.query.BQueryScheme.MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY -->
<field name="MAKE_ENTITY_FOR_ALTERNATE_SCOPE_FACET_KEY"  public="true" static="true" final="true">
<type class="java.lang.String"/>
<description>
This facet key will be checked on the base OrdTarget when resolving a query to decide whether&#xa; to create a new Entity object to use for the scope of the query to be resolved.  This facet key&#xa; is only checked for a &lt;code&gt;<see ref="javax.baja.sys.BBoolean#TRUE">BBoolean#TRUE</see>&lt;/code&gt; value when the &lt;code&gt;<see ref="javax.baja.query.BQueryScheme#ALTERNATE_SCOPE_FACET_KEY">#ALTERNATE_SCOPE_FACET_KEY</see>&lt;/code&gt;&#xa; facet is also specified on the base OrdTarget.  When these conditions are present, a new&#xa; Entity is created with an entity ORD matching that specified in the&#xa; &lt;code&gt;<see ref="javax.baja.query.BQueryScheme#ALTERNATE_SCOPE_FACET_KEY">#ALTERNATE_SCOPE_FACET_KEY</see>&lt;/code&gt; facet value.  This alternate Entity is then used as the&#xa; scope of the query.  This is useful to support lightweight Entity queries without requiring&#xa; the scope to be resolved in the station space first.
</description>
<tag name="@since">Niagara 4.6</tag>
</field>

</class>
</bajadoc>
