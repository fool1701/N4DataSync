<?xml version="1.0" encoding="UTF-8"?>
<bajadoc version="2.0" createdBy="niagara-baja-doclet-1.0.9" createdAt="03-May-2024" createdOn="883e7f7a9875">
<class module="baja" runtimeProfile="rt" qualifiedName="javax.baja.space.BComponentSpace" name="BComponentSpace" packageName="javax.baja.space" public="true">
<description>
BComponentSpace is a space which contains a slot tree of&#xa; BComponents.
</description>
<tag name="@author">Brian Frank</tag>
<extends>
<type class="javax.baja.space.BSpace"/>
</extends>
<implements>
<type class="javax.baja.security.BIProtected"/>
</implements>
<implements>
<type class="javax.baja.sys.BIPropertySpace"/>
</implements>
<implements>
<type class="javax.baja.dataRecovery.BIDataRecoverySource"/>
</implements>
<implements>
<type class="javax.baja.tag.BIEntitySpace"/>
</implements>
<annotation><type class="javax.baja.space.AuditableSpace"/>
</annotation>
<!-- javax.baja.space.BComponentSpace(java.lang.String, javax.baja.util.LexiconText, javax.baja.naming.BOrd) -->
<constructor name="BComponentSpace" public="true">
<parameter name="name">
<type class="java.lang.String"/>
</parameter>
<parameter name="lexText">
<type class="javax.baja.util.LexiconText"/>
</parameter>
<parameter name="ordInSession">
<type class="javax.baja.naming.BOrd"/>
</parameter>
<description>
Constructor.
</description>
</constructor>

<!-- javax.baja.space.BComponentSpace.getType() -->
<method name="getType"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.sys.Type"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getRootComponent() -->
<method name="getRootComponent"  public="true">
<description>
Get the root BComponent of this space.
</description>
<return>
<type class="javax.baja.sys.BComponent"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.setRootComponent(javax.baja.sys.BComponent) -->
<method name="setRootComponent"  public="true" synchronized="true">
<description>
Set the root BComponent of this space.
</description>
<parameter name="root">
<type class="javax.baja.sys.BComponent"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.isSpaceReadonly() -->
<method name="isSpaceReadonly"  public="true">
<description>
Return true if the entire component space is readonly.
</description>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getComponentCount() -->
<method name="getComponentCount"  public="true">
<description>
Get the number of components in this space.
</description>
<return>
<type class="int"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getAllComponents() -->
<method name="getAllComponents"  public="true">
<description>
Get an array copy of all the components contained by this space.
</description>
<return>
<type class="javax.baja.sys.BComponent" dimension="1"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getDefaultLeaseTime() -->
<method name="getDefaultLeaseTime"  public="true">
<description>
Defines the default lease time (in milliseconds) for components managed by this&#xa; component space.  Allows subclasses to override the default lease&#xa; time which is 60000 (or 60 seconds).
</description>
<tag name="@since">Niagara 3.7</tag>
<return>
<type class="long"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.subscribe(javax.baja.sys.Type[], javax.baja.sys.TypeSubscriber) -->
<method name="subscribe"  public="true">
<description>
Subscribe the provided TypeSubscriber to each of the specified&#xa; types.
</description>
<parameter name="t">
<type class="javax.baja.sys.Type" dimension="1"/>
</parameter>
<parameter name="s">
<type class="javax.baja.sys.TypeSubscriber"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.unsubscribe(javax.baja.sys.Type[], javax.baja.sys.TypeSubscriber) -->
<method name="unsubscribe"  public="true">
<description>
Unsubscribe the provided TypeSubscriber from each of the specified&#xa; types.
</description>
<parameter name="t">
<type class="javax.baja.sys.Type" dimension="1"/>
</parameter>
<parameter name="s">
<type class="javax.baja.sys.TypeSubscriber"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.updateSubscription(javax.baja.sys.Type[], javax.baja.sys.TypeSubscriber) -->
<method name="updateSubscription"  public="true">
<description>
Update the provided TypeSubscriber&#x27;s subscription to each of&#xa; the specified types.
</description>
<parameter name="t">
<type class="javax.baja.sys.Type" dimension="1"/>
</parameter>
<parameter name="s">
<type class="javax.baja.sys.TypeSubscriber"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.isSubscribed(javax.baja.sys.Type) -->
<method name="isSubscribed"  public="true">
<description>
Is the specified type currently subscribed to by a&#xa; TypeSubscriber?
</description>
<parameter name="t">
<type class="javax.baja.sys.Type"/>
</parameter>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.isSubscribed(javax.baja.sys.Type, int) -->
<method name="isSubscribed"  public="true">
<description>
Is the specified type currently subscribed to by a&#xa; TypeSubscriber for the specified component event id
</description>
<parameter name="t">
<type class="javax.baja.sys.Type"/>
</parameter>
<parameter name="componentEventId">
<type class="int"/>
</parameter>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.event(javax.baja.sys.BComponentEvent) -->
<method name="event"  public="true">
<description>
Provide the component space with an event that should be&#xa; sent to the subscribed TypeSubscribers.
</description>
<parameter name="event">
<type class="javax.baja.sys.BComponentEvent"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getOrdInSession() -->
<method name="getOrdInSession"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.naming.BOrd"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getLoadCallbacks() -->
<method name="getLoadCallbacks"  public="true">
<description>
Get the load callbacks for this space.
</description>
<return>
<type class="javax.baja.space.LoadCallbacks"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.setLoadCallbacks(javax.baja.space.LoadCallbacks) -->
<method name="setLoadCallbacks"  public="true">
<description>
Set the load callbacks for this space.
</description>
<parameter name="loadCallbacks">
<type class="javax.baja.space.LoadCallbacks"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getTrapCallbacks() -->
<method name="getTrapCallbacks"  public="true">
<description>
Get the trap callbacks for this space.
</description>
<return>
<type class="javax.baja.space.TrapCallbacks"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.setTrapCallbacks(javax.baja.space.TrapCallbacks) -->
<method name="setTrapCallbacks"  public="true">
<description>
Set the trap callbacks for this space.
</description>
<parameter name="trapCallbacks">
<type class="javax.baja.space.TrapCallbacks"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getSubscribeCallbacks() -->
<method name="getSubscribeCallbacks"  public="true">
<description>
Get the trap callbacks for this space.
</description>
<return>
<type class="javax.baja.space.SubscribeCallbacks"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.setSubscribeCallbacks(javax.baja.space.SubscribeCallbacks) -->
<method name="setSubscribeCallbacks"  public="true">
<description>
Set the trap callbacks for this space.
</description>
<parameter name="subscribeCallbacks">
<type class="javax.baja.space.SubscribeCallbacks"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.update(javax.baja.sys.BComponent, int) -->
<method name="update"  public="true" final="true">
<description>
Convenience for &lt;code&gt;getSubscribeCallbacks().update(c, depth)&lt;/code&gt;.
</description>
<parameter name="c">
<type class="javax.baja.sys.BComponent"/>
</parameter>
<parameter name="depth">
<type class="int"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.newTransaction() -->
<method name="newTransaction"  public="true" final="true">
<description>
Convenience for &lt;code&gt;newTransaction(null)&lt;/code&gt;.
</description>
<return>
<type class="javax.baja.sync.Transaction"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.newTransaction(javax.baja.sys.Context) -->
<method name="newTransaction"  public="true">
<description>
Get a transaction to use for this space.  This transaction&#xa; may be used as the context for BComponent modifications&#xa; to buffer up the changes.  When ready to apply the changes&#xa; use the &lt;code&gt;Transaction.commit()&lt;/code&gt;.
</description>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="javax.baja.sync.Transaction"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getEncodingContext(javax.baja.sys.Context) -->
<method name="getEncodingContext"  public="true">
<description/>
<tag name="@since">Niagara 4.0</tag>
<parameter name="base">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="javax.baja.sys.Context"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.modified(javax.baja.sys.BComponent, javax.baja.sys.Context) -->
<method name="modified"  public="true">
<description>
This callback is invoked when any modification is made on&#xa; the specified component.  This method is a convenient hook&#xa; to maintain a dirty flag.&#xa; &lt;p&gt;&#xa; Default implementation does nothing.
</description>
<parameter name="c">
<type class="javax.baja.sys.BComponent"/>
</parameter>
<parameter name="context">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.childParented(javax.baja.sys.BComponent, javax.baja.sys.Property, javax.baja.sys.BValue, javax.baja.sys.Context) -->
<method name="childParented"  public="true">
<description>
This is a callback for BComponent.childParented().&#xa; &lt;p&gt;&#xa; Default implementation does nothing.
</description>
<parameter name="c">
<type class="javax.baja.sys.BComponent"/>
</parameter>
<parameter name="property">
<type class="javax.baja.sys.Property"/>
</parameter>
<parameter name="newChild">
<type class="javax.baja.sys.BValue"/>
</parameter>
<parameter name="context">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.childUnparented(javax.baja.sys.BComponent, javax.baja.sys.Property, javax.baja.sys.BValue, javax.baja.sys.Context) -->
<method name="childUnparented"  public="true">
<description>
This is a callback for BComponent.childUnparented().&#xa; &lt;p&gt;&#xa; Default implementation does nothing.
</description>
<parameter name="c">
<type class="javax.baja.sys.BComponent"/>
</parameter>
<parameter name="property">
<type class="javax.baja.sys.Property"/>
</parameter>
<parameter name="oldChild">
<type class="javax.baja.sys.BValue"/>
</parameter>
<parameter name="context">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.fireDirectCallbacks() -->
<method name="fireDirectCallbacks"  public="true">
<description>
This method indicates if callbacks which are normally&#xa; fired directly on the component itself should be&#xa; suppressed or fired as normal.&#xa; &lt;p&gt;&#xa; Default is to return true.
</description>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.isProxyComponentSpace() -->
<method name="isProxyComponentSpace"  public="true">
<description>
Return true if this a proxy component space.  Proxy&#xa; component spaces never generate handles themselves.&#xa; Proxy spaces should subclass BProxyComponentSpace.
</description>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.sync() -->
<method name="sync"  public="true">
<description>
If this is a proxy component space, then this performs&#xa; a sync with the master space.  Otherwise this is a no op.
</description>
<return>
<type class="void"/>
</return>
<throws>
<type class="java.lang.Exception"/>
</throws>
</method>

<!-- javax.baja.space.BComponentSpace.findByHandle(java.lang.Object) -->
<method name="findByHandle"  public="true" final="true">
<description>
Convenience for &lt;code&gt;findByHandle(handle, true)&lt;/code&gt;.
</description>
<parameter name="handle">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="javax.baja.sys.BComponent"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findByHandle(java.lang.Object, boolean) -->
<method name="findByHandle"  public="true">
<description>
Get a BComponent within this space by handle,&#xa; or return null if not found.
</description>
<parameter name="handle">
<type class="java.lang.Object"/>
</parameter>
<parameter name="autoLoad">
<type class="boolean"/>
</parameter>
<return>
<type class="javax.baja.sys.BComponent"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.doFindByHandle(java.lang.Object, boolean) -->
<method name="doFindByHandle"  protected="true">
<description>
Allows proxy component space subclasses to override the behavior&#xa; of findByHandle.
</description>
<tag name="@since">Niagara 3.7</tag>
<parameter name="handle">
<type class="java.lang.Object"/>
</parameter>
<parameter name="autoLoad">
<type class="boolean"/>
</parameter>
<return>
<type class="javax.baja.sys.BComponent"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.resolveByHandle(java.lang.Object) -->
<method name="resolveByHandle"  public="true" final="true">
<description>
Get a BComponent within this space by handle,&#xa; or throw UnresolvedException.
</description>
<parameter name="handle">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="javax.baja.sys.BComponent"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.handleToSlotPath(java.lang.Object) -->
<method name="handleToSlotPath"  public="true">
<description>
Map a handle to a slot path.  Return null if handle&#xa; does not identify a valid component in this space.
</description>
<parameter name="handle">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="javax.baja.naming.SlotPath"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.handlesToSlotPaths(java.lang.Object[]) -->
<method name="handlesToSlotPaths"  public="true">
<description>
Map an array of handles to an array of SlotPaths.&#xa; Any handle in the array which does not identify a&#xa; valid component results in null.
</description>
<parameter name="handles">
<type class="java.lang.Object" dimension="1"/>
</parameter>
<return>
<type class="javax.baja.naming.SlotPath" dimension="1"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.iterateAllComponents() -->
<method name="iterateAllComponents"  public="true">
<description>
Get an Iterator for all components in the space. This includes&#xa; the root of the componenet tree.
</description>
<tag name="@since">Niagara 4.0</tag>
<return>
<parameterizedType class="java.util.Iterator">
<args>
<type class="javax.baja.sys.BComponent"/>
</args>
</parameterizedType>
<description>
Returns an Iterator of all components in the space.&#xa; The order of the returned components is unpredictable and&#xa; unrelated to the component tree structure.
</description>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getEnabledMixIns() -->
<method name="getEnabledMixIns"  public="true">
<description>
Get the list of MixIn types which are currently enabled&#xa; on this component space.  This may be modified using the&#xa; &lt;code&gt;enableMixIn()&lt;/code&gt; and &lt;code&gt;disableMixIn()&lt;/code&gt;&#xa; methods.
</description>
<return>
<type class="javax.baja.sys.Type" dimension="1"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.enableMixIn(javax.baja.sys.Type) -->
<method name="enableMixIn"  public="true" synchronized="true">
<description>
Enable the specified MixIn type.  This call will automatically&#xa; add an instance of the MixIn for all the components in this&#xa; space which the MixIn is an agent on.
</description>
<parameter name="mixInType">
<type class="javax.baja.sys.Type"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.disableMixIn(javax.baja.sys.Type) -->
<method name="disableMixIn"  public="true" synchronized="true">
<description>
Disable the specified MixIn type in the component space.  This&#xa; call prevents the MixIn from being added to new components, but&#xa; does not effect any existing components currently containing&#xa; the MixIn.
</description>
<parameter name="mixInType">
<type class="javax.baja.sys.Type"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getCategoryMask() -->
<method name="getCategoryMask"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Return the root&#x27;s category mask.
</description>
<return>
<type class="javax.baja.category.BCategoryMask"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getAppliedCategoryMask() -->
<method name="getAppliedCategoryMask"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Return the root&#x27;s category mask.
</description>
<return>
<type class="javax.baja.category.BCategoryMask"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getPermissions(javax.baja.sys.Context) -->
<method name="getPermissions"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
</parameter>
<return>
<type class="javax.baja.security.BPermissions"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.canRead(javax.baja.naming.OrdTarget) -->
<method name="canRead"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="cx">
<type class="javax.baja.naming.OrdTarget"/>
</parameter>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.canWrite(javax.baja.naming.OrdTarget) -->
<method name="canWrite"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="cx">
<type class="javax.baja.naming.OrdTarget"/>
</parameter>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.canInvoke(javax.baja.naming.OrdTarget) -->
<method name="canInvoke"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="cx">
<type class="javax.baja.naming.OrdTarget"/>
</parameter>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findObjects(javax.baja.sys.Type, javax.baja.naming.BOrd, java.lang.String, javax.baja.sys.Context) -->
<method name="findObjects"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Find the objects with a property with the specified name.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="objectType">
<type class="javax.baja.sys.Type"/>
<description>
The common type of the objects to return in the result.&#xa;                     If null, the result is not filtered by object type.
</description>
</parameter>
<parameter name="baseOrd">
<type class="javax.baja.naming.BOrd"/>
<description>
The base ord from which to start&#xa;                     searching (only objects that are descendants of this base&#xa;                     will be included in the result).  If null, the search will include the entire space.
</description>
</parameter>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to search for.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the search.
</description>
</parameter>
<return>
<parameterizedType class="javax.baja.sys.Cursor">
<args>
<wildcardType class="?">
<bounds kind="extends">
<type class="javax.baja.sys.BIObject"/>
</bounds>
</wildcardType>
</args>
</parameterizedType>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findObjects(javax.baja.sys.Type, javax.baja.naming.BOrd, java.lang.String, javax.baja.sys.Type, javax.baja.sys.Context) -->
<method name="findObjects"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Find the objects with a property with the specified name and type.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="objectType">
<type class="javax.baja.sys.Type"/>
<description>
The common type of the objects to return in the result.&#xa;                     If null, the result is not filtered by object type.
</description>
</parameter>
<parameter name="baseOrd">
<type class="javax.baja.naming.BOrd"/>
<description>
The base ord from which to start&#xa;                     searching (only objects that are descendants of this base&#xa;                     will be included in the result).  If null, the search will include the entire space.
</description>
</parameter>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to search for.
</description>
</parameter>
<parameter name="propertyType">
<type class="javax.baja.sys.Type"/>
<description>
The type of the property to search for.  If null,&#xa;                     any types will be included that have the given propertyName.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the search.
</description>
</parameter>
<return>
<parameterizedType class="javax.baja.sys.Cursor">
<args>
<wildcardType class="?">
<bounds kind="extends">
<type class="javax.baja.sys.BIObject"/>
</bounds>
</wildcardType>
</args>
</parameterizedType>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findObjects(javax.baja.sys.Type, javax.baja.naming.BOrd, java.lang.String, javax.baja.sys.BValue, javax.baja.sys.Context) -->
<method name="findObjects"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Find the objects with the specified property name and value.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="objectType">
<type class="javax.baja.sys.Type"/>
<description>
The common type of the objects to return in the result.&#xa;                      If null, the result is not filtered by object type.
</description>
</parameter>
<parameter name="baseOrd">
<type class="javax.baja.naming.BOrd"/>
<description>
The base ord from which to start&#xa;                      searching (only objects that are descendants of this base&#xa;                      will be included in the result).  If null, the search will include the entire space.
</description>
</parameter>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to search for.
</description>
</parameter>
<parameter name="propertyValue">
<type class="javax.baja.sys.BValue"/>
<description>
The value of the property to search for.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the search.
</description>
</parameter>
<return>
<parameterizedType class="javax.baja.sys.Cursor">
<args>
<wildcardType class="?">
<bounds kind="extends">
<type class="javax.baja.sys.BIObject"/>
</bounds>
</wildcardType>
</args>
</parameterizedType>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findDistinctValues(javax.baja.sys.Type, javax.baja.naming.BOrd, java.lang.String, javax.baja.sys.Context) -->
<method name="findDistinctValues"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Find the distinct values for the specified property name within the space.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="objectType">
<type class="javax.baja.sys.Type"/>
<description>
The common type of the objects to return in the result.&#xa;                     If null, the result is not filtered by object type.
</description>
</parameter>
<parameter name="baseOrd">
<type class="javax.baja.naming.BOrd"/>
<description>
The base ord from which to start&#xa;                     searching (only objects that are descendants of this base&#xa;                     will be included in the result).  If null, the search will include the entire space.
</description>
</parameter>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to search for.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the search.
</description>
</parameter>
<return>
<parameterizedType class="javax.baja.sys.Cursor">
<args>
<wildcardType class="?">
<bounds kind="extends">
<type class="javax.baja.sys.BIObject"/>
</bounds>
</wildcardType>
</args>
</parameterizedType>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.findDistinctValues(javax.baja.sys.Type, javax.baja.naming.BOrd, java.lang.String, javax.baja.sys.Type, javax.baja.sys.Context) -->
<method name="findDistinctValues"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Find the distinct values for the specified property name and type within the space.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="objectType">
<type class="javax.baja.sys.Type"/>
<description>
The common type of the objects to return in the result.&#xa;                     If null, the result is not filtered by object type.
</description>
</parameter>
<parameter name="baseOrd">
<type class="javax.baja.naming.BOrd"/>
<description>
The base ord from which to start&#xa;                     searching (only objects that are descendants of this base&#xa;                     will be included in the result).  If null, the search will include the entire space.
</description>
</parameter>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to search for.
</description>
</parameter>
<parameter name="propertyType">
<type class="javax.baja.sys.Type"/>
<description>
The type of the property to search for.  If null,&#xa;                     any types will be included that have the given propertyName.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the search.
</description>
</parameter>
<return>
<parameterizedType class="javax.baja.sys.Cursor">
<args>
<wildcardType class="?">
<bounds kind="extends">
<type class="javax.baja.sys.BIObject"/>
</bounds>
</wildcardType>
</args>
</parameterizedType>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.addIndex(java.lang.String, javax.baja.sys.Context) -->
<method name="addIndex"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Index the specified property.  Indexed properties should be more efficient to search.&#xa; Implementation of indexing is optional.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property to index.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the operation.
</description>
</parameter>
<return>
<type class="boolean"/>
<description>
Returns true if the requested index was created, false otherwise.
</description>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.removeIndex(java.lang.String, javax.baja.sys.Context) -->
<method name="removeIndex"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Remove the index for the specified property.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="propertyName">
<type class="java.lang.String"/>
<description>
The name of the property that should no longer be indexed.
</description>
</parameter>
<parameter name="cx">
<type class="javax.baja.sys.Context"/>
<description>
The context for the operation.
</description>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.fw(int, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object) -->
<method name="fw"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="x">
<type class="int"/>
</parameter>
<parameter name="a">
<type class="java.lang.Object"/>
</parameter>
<parameter name="b">
<type class="java.lang.Object"/>
</parameter>
<parameter name="c">
<type class="java.lang.Object"/>
</parameter>
<parameter name="d">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="java.lang.Object"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.mount(java.lang.Object) -->
<method name="mount"  protected="true" synchronized="true">
<description/>
<parameter name="support">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.unmount(java.lang.Object) -->
<method name="unmount"  protected="true" synchronized="true">
<description/>
<parameter name="support">
<type class="java.lang.Object"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.hasNavChildren() -->
<method name="hasNavChildren"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getNavChild(java.lang.String) -->
<method name="getNavChild"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="name">
<type class="java.lang.String"/>
</parameter>
<return>
<type class="javax.baja.nav.BINavNode"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getNavChildren() -->
<method name="getNavChildren"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.nav.BINavNode" dimension="1"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getNavIcon() -->
<method name="getNavIcon"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.sys.BIcon"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getNavOrd() -->
<method name="getNavOrd"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.naming.BOrd"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.getTagDictionaryService() -->
<method name="getTagDictionaryService"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<return>
<type class="javax.baja.tag.TagDictionaryService"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.setTagDictionaryService(javax.baja.tag.TagDictionaryService) -->
<method name="setTagDictionaryService"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="service">
<type class="javax.baja.tag.TagDictionaryService"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.removeTagDictionaryService(javax.baja.tag.TagDictionaryService) -->
<method name="removeTagDictionaryService"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description/>
<parameter name="service">
<type class="javax.baja.tag.TagDictionaryService"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.spy(javax.baja.spy.SpyWriter) -->
<method name="spy"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Dump slots and information common to all BComplex&#x27;s.
</description>
<parameter name="out">
<type class="javax.baja.spy.SpyWriter"/>
</parameter>
<return>
<type class="void"/>
</return>
<throws>
<type class="java.lang.Exception"/>
</throws>
</method>

<!-- javax.baja.space.BComponentSpace.dataRecoveryRestore(javax.baja.dataRecovery.IDataRecoveryRecord) -->
<method name="dataRecoveryRestore"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Called by the DataRecoveryService when a record should be restored.
</description>
<tag name="@since">Niagara 3.6</tag>
<parameter name="rec">
<type class="javax.baja.dataRecovery.IDataRecoveryRecord"/>
</parameter>
<return>
<type class="boolean"/>
</return>
<throws>
<type class="java.lang.Exception"/>
</throws>
</method>

<!-- javax.baja.space.BComponentSpace.dataRecoveryRestoreComplete() -->
<method name="dataRecoveryRestoreComplete"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Callback to indicate that no further records will be restored to this source.
</description>
<tag name="@since">Niagara 3.6</tag>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.space.BComponentSpace.dataRecoverySpy(javax.baja.spy.SpyWriter, java.util.Iterator&lt;javax.baja.dataRecovery.IDataRecoveryRecord&gt;) -->
<method name="dataRecoverySpy"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Decode the data recovery provided to you by the Iterator and place it&#xa; into the SpyWriter for runtime analysis for the DataRecoverySource.
</description>
<tag name="@since">Niagara 3.6</tag>
<parameter name="out">
<type class="javax.baja.spy.SpyWriter"/>
</parameter>
<parameter name="recoveryData">
<parameterizedType class="java.util.Iterator">
<args>
<type class="javax.baja.dataRecovery.IDataRecoveryRecord"/>
</args>
</parameterizedType>
</parameter>
<return>
<type class="void"/>
</return>
<throws>
<type class="java.lang.Exception"/>
</throws>
</method>

<!-- javax.baja.space.BComponentSpace.TYPE -->
<field name="TYPE"  public="true" static="true" final="true">
<type class="javax.baja.sys.Type"/>
<description/>
</field>

</class>
</bajadoc>
