<!-- Htmldoc has been run -->
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>
<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/bqlExamples.html" class="navbar">Prev</a> |  <a href="/doc/search.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.javascript-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.css-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<h1 id="neql">NEQL</h1>
<h2 id="introduction">Introduction</h2>
<p>The main design goal of NEQL is to provide a simple mechanism for querying taggable entities from Niagara applications.  BQL does not meet the need because it was designed specifically with the Niagara component space and component API in mind.  BQL could not be modified to meet the goal because of the risk of breaking existing applications based on BQL.</p>
<h2 id="primary-differences-between-neql-and-bql">Primary differences between NEQL and BQL</h2>
<ol>
  <li>NEQL only queries for tags using the Niagara 4 Taggable and Entity APIs.</li>
  <li>NEQL supports traversing defined entity relationships.</li>
  <li>NEQL supports parameterized queries.</li>
  <li>NEQL does not support the tree semantics and pathing of the Niagara component space. (ex. parent.parent)</li>
  <li>NEQL does not support projection and only returns entities so the projection if any in the NEQL are not used.</li>
  <li>NEQL does not support BFormat operations.</li>
</ol>
<h2 id="neql-grammar">NEQL Grammar</h2>
<pre><code>&lt;statement&gt; := &lt;full select&gt; | &lt;filter select&gt; | &lt;traverse&gt;

&lt;full select&gt; := select &lt;tag list&gt; where &lt;predicate&gt;

&lt;filter select&gt; := &lt;predicate&gt;

&lt;traverse&gt; := traverse &lt;relation&gt; (where &lt;predicate&gt;)

&lt;tag list&gt; := &lt;tag&gt; (, &lt;tag&gt;)*

&lt;tag&gt; := (&lt;namespace&gt;:)&lt;key&gt;

&lt;relation&gt; := (&lt;namespace&gt;:)&lt;key&gt;&lt;direction&gt;

&lt;namespace&gt; := &lt;word&gt;

&lt;key&gt; := &lt;word&gt;

&lt;direction&gt; := -&gt;  |  &lt;-

&lt;predicate&gt; := &lt;condOr&gt;

&lt;condOr&gt; := &lt;condAnd&gt; (or &lt;condAnd&gt;)*

&lt;condAnd&gt; := &lt;term&gt; (and &lt;term&gt;)* 

&lt;term&gt; := &lt;cmp&gt; | &lt;tagPath&gt; | &lt;not&gt; | &lt;relation&gt;+

&lt;cmp&gt; := &lt;comparable&gt; &lt;cmpOp&gt; &lt;comparable&gt; | &lt;like&gt;

&lt;like&gt; := &lt;tagPath&gt; like &lt;regex&gt;

&lt;cmpOp&gt; :=  =  |  !=  |  &lt;  |  &lt;=  |  &gt;  |  &gt;=

&lt;comparable&gt; := &lt;val&gt; | &lt;tagPath&gt;

&lt;val&gt; := &lt;number&gt; | &lt;bool&gt; | &lt;str&gt;

&lt;tagPath&gt; := (&lt;relation&gt;)*&lt;tag&gt;

&lt;not&gt; := not &lt;negatable&gt; | !&lt;negatable&gt;

&lt;negatable&gt; := (&lt;predicate&gt;) | &lt;tag&gt; // note: parens around &lt;predicate&gt; signify actual paren characters, NOT optional syntax

&lt;number&gt; := &lt;int&gt; | &lt;double&gt;

&lt;bool&gt; := true | false

&lt;str&gt; := &quot;&lt;chars&gt;&quot;

&lt;word&gt; := &lt;chars&gt;

&lt;regex&gt; := &quot;&lt;chars&gt;&quot; // note: some regex edge cases not supported
</code></pre>
<h2 id="examples">Examples</h2>
<pre><code>// returns all points, in namespace &quot;n&quot;
n:point

// Projection is not supported in NEQL, note that results are same as n:point.
select n:name, n:displayName where n:point  

// both return all the points in namespace &quot;n&quot;, restricted by yearBuilt tag in namespace &quot;hs&quot;.
hs:yearBuilt &gt;2015
select n:name, n:displayName where hs:yearBuilt &gt; 2015

// returns all the points which was either built later than 2015 or the primary function is backup.
hs:yearBuilt &gt;2015 or hs:primaryFunction = &quot;backup&quot; 

// returns only the points which are greater than 150 and less than or equal to 400.
hs:area &gt; 150 and hs:area &lt;= 400

// returns all the matches.
true

// no matches are returned.
false

// returns only the point whose primary function is backup.
hs:primaryFunction = &quot;backup&quot; 	

// matches everything.
&quot;something&quot;=&quot;something&quot; 
10 &lt; 12

// returns all entities whose grandparent's name contains the word &quot;Basement&quot;
// (refer to the Pattern class in the java.util.regex package for regex help)
n:parent-&gt;n:parent-&gt;n:name like &quot;.*Basement.*&quot;

// Known issue: if the relation path is not unique, then only first match is checked
// (e.g. if an entity has many children, this query will only return the entity if its first child has n:name = &quot;OutsideTemp&quot;)
n:child-&gt;n:name=&quot;OutsideTemp&quot;
</code></pre>
<h2 id="tag-expressions-in-neql">Tag Expressions in NEQL</h2>
<p>Tags are in the form of subject-predicate-object expressions. The subject denotes the resource, and the predicate denotes traits or aspects of the resource and expresses a relationship between the subject and the object. In the Niagara Component Space, BComponents are subjects, the Tag Id is the predicate and the Tag value is the object. The Id is generally displayed in the form dictionaryNamespace:name. If the dictionary is an empty string, default dictionary defined in the tag dictionary service is used. The dictionary namespace is typically a very short string, i.e., one or two characters.  The Tag value is just that, i.e., the value of the tag.  In Resource Description Framework terminology the thing that the Tag is applied to is the subject, the Id is the predicate and the value is the object.</p>
<pre><code>** Marker tags **
Some tags may not require a value.  In this case, the fact that the subject has the tag applied
is sufficient to convey the semantic information. These tags are referred to as Marker tags.	

Example:
hs:equip is an example of marker tag. Apply this tag to all the equipment - Pump, boiler, heater etc.
hs:equip, will returns all the equipment which have this tag associated with them.


**String**
&quot;=&quot;,&quot;!=&quot;, these operators apply here.Note that the match is case sensitive	

// list all items tagged with this implied tag
n:name

// returns component with name MyComponent
n:name = &quot;MyComponent&quot;

//returns all strings which contain Xing
neql:n:name like \&quot;.*Xing.*\&quot;


**Double**
&quot;=&quot;,&quot;!=&quot;,&quot;&lt;&quot;,&quot;&lt;=&quot;,&quot;&gt;&quot;,&quot;&gt;=&quot;, these operators apply here.

Assign hs:area tag with value 400.00 to HotWaterPump and 150.00 to CoolingTower

// returns both HotWaterPump and CoolingTower.
hs:area, returns both HotWaterPump and CoolingTower.

// returns both HotWaterPump and CoolingTower
hs:area &gt;= 150

// returns HotWaterPump
neql:hs:area &gt; 190

**Long**
Same as Double above.

**Integer**
Same as Double above.
</code></pre>
<p><strong>Note</strong> More information about tagging and dictionaries can be found in the <a href="module://docTagging/doc/tagdictionary-TagDictionary.html">Tag Dictionaries</a> documentation.</p>
<h2 id="select-vs-traverse">Select vs Traverse</h2>
<p>A Select statement is a NEQL statement for selecting a collection of Entities, whereas a Traverse statement is a NEQL statement for selecting a collection of Entities by traversing a relation from either end of the relation.</p>
<pre><code>** Select statement example:**
// returns everything other than Services
select name where  n:name != &quot;Services&quot;

// returns Cooling tower and HotWaterPump 
select name where hs:area &gt;= 150, 	


** Traverse Statement example:**
This example returns all the outbound child relations going from parent node to all
the child nodes under it.

traverse n:child-&gt; 

The following returns all the outbound child relations going from parent node to all
the child nodes under it while restricting the child nodes to component name with NumericWritable.

traverse n:child-&gt; where n:name = 'NumericWritable'
</code></pre>
<h2 id="neql-scope">NEQL Scope</h2>
<pre><code>Suppose that we have a station's NiagaraNetwork configured as follows:
Two stations - supervisor and another subordinate both up and running. The subordinate station
has BooleanPoint and NumericPoint. Next on the supervisor discover subordinate and add it to
supervisor station. Also discover and add the two Points - the Boolean and NumericPoint as well.
So the supervisor looks like the following:

supervisor
--Drivers
---NiagaraNetwork
//subordinate is a device
-----subordinate
-------Points
----------NumericPoint
----------BooleanPoint

// Following example limits scope to all BDevices associated with supervisor.
BOrd nDeviceSearchOrd = BOrd.make(&quot;neql: n:device&quot;);

// supervisor below, refers to the handle to the supervisor station. 
BQueryResult r = (BQueryResult)nDeviceSearchOrd.get(supervisor); 

The above result set has all the devices under the NiagaraNetwork, here in this case the
result has device, subordinate.

// Now applying &quot;traverse n:childPoint-&gt;&quot; on subordinate(at subordinate scope)
BOrd nTraverseChildOrd = BOrd.make(&quot;neql:traverse n:childPoint-&gt;&quot;);

//subordinate, refers to the handle to the discovered subordinate station under supervisor station.
BQueryResult r = (BQueryResult)nTraverseChildOrd.get(subordinate);

The above result has two child outbound relations, one each to NumericPoint 
and BooleanPoint from the subordinate station.
</code></pre>
<h2 id="scalar-and-aggregate-functions">Scalar and Aggregate Functions</h2>
<pre><code>Not supported.
</code></pre>
<h2 id="neql-using-java">NEQL using Java</h2>
<pre><code>**Searching for the AHU using Java code:**
// handle to system out.
Consumer&lt;Object&gt; print = (output) -&gt; System.out.println(output);

For example let's say we have a Heating System component - HSComponent. This HSComponent has lot
of things including AHU unit tagged with &quot;ahu&quot; and &quot;equip&quot;.  

// only one unit with both ahu and equip tag
BOrd query = BOrd.make(&quot;neql: hs:equip and hs:ahu&quot;); 
BQueryResult result = (BQueryResult)query.resolve(HSComponentInstance).get();
Iterator&lt;Entity&gt; results = result.getResults();

// print out all the entities it finds tagged with ahu and equip.
results.stream().forEach(entity -&gt; System.out.println(((BComponent)entity).getName()));


** Facet Context Expression **
BFacets is a map of name/value pairs used to annotate a BComplex's Slot or to just provide additional metadata about something. A Context Expression is an expression that is evaluated
against the query context.  Typically the query context is the base object from the ord that
the query is part of.

//create a facet name/value integerValue50 with value of 50
BFacets facets = BFacets.make(&quot;integerValue50&quot;, 50);

BComponent root = new BComponent();
// add two childValue's with value of 50
for (int i = 0; i &lt; 2; i++)
{
  BComponent child1 = new BComponent();
  child1.add(&quot;childValue50&quot;, BInteger.make(50));
  root.add(&quot;child?&quot;, child1);
}

// add 3 childValue's with value 100
for (int i = 0; i &lt; 3; i++)
{
  BComponent child1 = new BComponent();
  child1.add(&quot;integerValue100&quot;, BInteger.make(100));
  root.add(&quot;child?&quot;, child1);
}

// use facet integerValue50 as context expression
BOrd query = BOrd.make(&quot;neql:childValue50 = {integerValue50}&quot;);

// search under root to see if there are any component(s) with same property value as integerValue50.
BQueryResult result = (BQueryResult)query.resolve(root, facets).get();

// Number of matching components printed will be 2, which is the number of components with value 50
print.accept(&quot;Number of matching components : &quot; + result.stream().count());


** Traverse Out With Predicate **
// create a root component
BComponent root = new BComponent();

// add 3 child components with foo Marker to the root above
for (int i = 0; i &lt; 3; i++)
{
  BComponent child = new BComponent();
  child.tags().set(Id.newId(&quot;n:foo&quot;), BMarker.MARKER);
  root.add(&quot;child?&quot;, child);
  root.relations().add(Id.newId(&quot;n:child&quot;), child, false);
}

// add 3 child components with bar Marker to the root above
for (int i = 0; i &lt; 3; i++)
{
  BComponent child = new BComponent();
  child.tags().set(Id.newId(&quot;n:bar&quot;), BMarker.MARKER);
  root.add(&quot;child?&quot;, child);
  root.relations().add(Id.newId(&quot;n:child&quot;), child, false);
}

// traverse for 3 components with foo marker tag
BOrd query = BOrd.make(&quot;neql:traverse n:child -&gt; where n:foo&quot;);
BQueryResult result = (BQueryResult)query.resolve(root).get();
print.accept(&quot;Number of components with foo marker tag:  &quot; + result.stream().count());

// traverse for the 6 components with either foo or bar marker tag
query = BOrd.make(&quot;neql:traverse n:child -&gt; where n:foo or n:bar&quot;);
result = (BQueryResult)query.resolve(root).get();
print.accept(&quot;Number of components with foo or bar marker tag:  &quot; + result.stream().count());
</code></pre>

<script type='text/javascript'>window.niagara.docDevUtil.highlightCode();</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/bqlExamples.html" class="navbar">Prev</a> |  <a href="/doc/search.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
