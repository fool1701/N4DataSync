<!-- Htmldoc has been run -->
<!--
   @author    Brian Frank
   @creation  25 Jan 05
   @version   $Revision$ $Date$
   @since     Niagara 3.0
 -->
 
<html>

<head>
<title>Remote Programming</title>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>

<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/station.html" class="navbar">Prev</a> |  <a href="/doc/files.html" class="navbar">Next</a></p>


<!-- Title Block -->
<h1 class='title'>Remote Programming</h1> 

<!------------------------------------------------------------->
<h1 id="overview">Overview</h1>
<!------------------------------------------------------------->

<table align="center">
  <tr><td align="center">
    <img src="fox.jpg" border="0">
  </td></tr>
</table>

<p>
Remote programming is one of the most powerful features of Niagara.  
It is also the number one cause of confusion and performance problems.
The term <i>remote programming</i> broadly applies to using the component
model across a network connection.  Some topics like subscription are
critical concepts for many subsystems.  But most often remote programming
applies to programming with components in the workbench across a fox
connection to a station (<a href='arch-remoteProgramming.html'>illustration</a>).
</p>                

<p> 
The component model provides a number features for network programming:
</p>                                                                   

<ul> 
<li>Lazy loading of a component tree across the network;</li> 
<li>Automatic synchronization of database tree structure over network;</li> 
<li>Ability to subscribe to real-time property changes and topic events;</li> 
<li>Ability to invoke an action over the network like an RPC;</li> 
<li>Support for timed subscriptions called leasing;</li> 
<li>Automatic support for propagating components changes over network;</li> 
<li>Ability to batch most network calls;</li> 
</ul> 

<!------------------------------------------------------------->
<h1 id="fundamentals">Fundamentals</h1>
<!------------------------------------------------------------->

<p>
The component model has the ability to make remote programming virtually
transparent.  In this <a href='arch-remoteProgramming.html'>diagram</a>,
the component "/a/b" is accessed in the workbench VM, but actually lives
and is executing in the station VM.  The instance of the component in the 
workbench is called the <i>proxy</i> and the instance in the station is
called the <i>master</i>.
</p>                     

<p>
The first thing to note in Niagara is that both the proxy and master are 
instances of the same class.  This is unlike technologies such as RMI where 
the proxy is accessed using a special interface.  Also unlike RMI and its 
brethren, nothing special is required to make a component remote accessible.  
All Niagara components are automatically remotable by virtue of subclassing 
BComponent.
</p>                                          

<p>
From an API perspective there is no difference between programming against a
proxy or a master component. Both are instances of the same class with the same
methods. However, sometimes it is important to make a distinction. The most
common way to achieve this is via the <code>BComponent.isRunning()</code>
method. A master component will return true and a proxy false. Although
<code>isRunning()</code> is usually suitable for most circumstances,
technically it covers other semantics such as working offline. The specific
call for checking proxy status is via
<code>BComponent.getComponentSpace().isProxyComponentSpace()</code>.
</p>

<p>
Note that proxy components receive all the standard change callbacks like
<code>changed()</code> or <code>added()</code>. Typically developers should
short circuit these callbacks if the component is not running since executing
callback code within a proxy can produce unintended side effects.
</p>     

<!------------------------------------------------------------->
<h1 id="proxyFeatures">Proxy Features</h1>
<!------------------------------------------------------------->

<p>
The framework provides a host of features which lets you program
against a proxy component transparently:
<p>

<ul>
<li>The proxy can maintain the state of the master by synchronizing
all properties in real-time;</li>
<li>Actions on the proxy act like RPCs;</li>
<li>Any changes to the proxy are automatically propagated to the master;</li>
</ul>

<p>
The framework provides the ability to keep a proxy's properties completely
synchronized in real-time to the master using <i>subscription</i>. While
subscribed all property changes are immediately reflected in the proxy.  This
enables easy development of user interfaces that reflect the current state of
a component. Note that only properties support this feature - other fields of
your class will not be synchronized, and likely will be invalid if they are
populated via station execution. Subscription is covered in more detail later.
</p>

<p>
Another feature of Niagara is that all actions automatically act like RPCs
(Remote Procedure Calls). When you invoke an action on a proxy, it
automatically marshals the argument across the network, invokes the action on
the master, and then marshals the result back to the proxy VM. Note that all
other methods are invoked locally.
</p>            

<p>
Perhaps the most powerful feature of proxies is the ability to transparently
and automatically propagate proxy side changes to the master. For example when
you set a property on a proxy, it actually marshals the change over the network
and makes the set on the master (which in turn synchronizes to the proxy once
complete). This functionality works for all component changes: sets, adds,
removes, renames, reorders, flag sets, and facet sets. Note that if making many
changes it is more economical to batch the changes using a Transaction; this is
discussed later.
</p>

<!------------------------------------------------------------->
<h1 id="proxyStates">Proxy States</h1>
<!------------------------------------------------------------->

<p>
A proxy component exists in three distinct states:
</p>

<ul>
<li><b>Unloaded</b>:  in this state the proxy has not
even been loaded across the network.</li>
<li><b>Loaded</b>:  in this state the proxy is loaded
across the network and is known to the proxy VM;  it may
or may not be out-of-date with the master.</li>
<li><b>Subscribed</b>:  in this state the proxy is actively 
synchronized with the master.</li>
</ul> 

<p>
When a session is first opened to a station, none of the components in the
station are known in the workbench. Rather components are lazily loaded into
the workbench only when needed. Components which haven't been loaded yet are
called <i>unloaded</i>.
</p>

<p>
Components become <i>loaded</i> via the <code>BComplex.loadSlots()</code>
method.  Components must always be loaded according to their tree structure,
thus once loaded it is guaranteed that all a component's ancestors are
also loaded.  Rarely does a developer use the <code>loadSlots()</code>
method.  Rather components are loaded as the user expands the navigation
tree or a component is resolved by ord.
</p>

<p>
A loaded component means that a proxy instance representing the master component
has been created in the workbench.  The proxy instance is of the same
class as the master, and occupies a slot in the tree structure identical
to the master (remember all ancestors must also be loaded).  The proxy
has the same <i>identity</i> as the master.  That means calling methods such 
as <code>getName()</code>, <code>getHandle()</code>, and <code>getSlotPath()</code> 
return the same result.  However, note that the absolute ords of a proxy and 
master will be different since the proxy's ord includes how it was accessed over
the network (<a href='arch-remoteProgramming.html'>see diagram</a>).
</p>

<p>
Once a proxy component has been loaded, it remains cached in the loaded state
until the session is closed. Loaded proxies maintain their structure and
identity automatically through the use of NavEvents. NavEvents are always
routed across the network to maintain the proxy tree structure independent of
the more fine grained component eventing. For example if a loaded component is 
renamed, it always reflects the new name independent of subscription state.  
Or if removed it is automatically removed from the cache.
</p>

<p>
Loaded components provide a cache of structure and identity, but they do not
guarantee access to the current state of the master via its properties. The
<i>subscribed</i> state is used to synchronize a proxy with its master.
Subscription is achieved using a variety of mechanisms discussed next. Once
subscribed a component is guaranteed to have all its property values
synchronized and kept up-to-date with the master. Subscription is an expensive
state compared to just being loaded, therefore it is important to unsubscribe
when finished working with a proxy.
</p>  

<!------------------------------------------------------------->
<h1 id="proxyStates">Subscription</h1>
<!------------------------------------------------------------->

<p>
Subscription is a concept used throughout the framework. Components commonly
model entities external to the VM. For example, proxy components model a master
component in the station VM. Likewise, components in a station often model an
external system or device. Keeping components synchronized with their external
representations is usually computationally expensive. Therefore all components
are built with a mechanism to be notified when they really need to be
synchronized. This mechanism is called <i>subscription</i>.
</p>                                    

<p>
Subscription is a boolean state. A component can check its current state via
the <code>BComponent.isSubscribed()</code> method. The
<code>subscribed()</code> callback is invoked when entering the subscribed
state, and <code>unsubscribed()</code> when exiting the subscribed state. The
subscribed state means that something is currently interested in the component.
Subscribed usually means the component should attempt to keep itself
synchronized through polling or eventing. The unsubscribed state may be used to
disable synchronization to save CPU, memory, or bandwidth resources.
</p>               

<p> 
Subscriptions often chain across multiple tiers.  For example when you
subscribe to a component in the workbench, that subscribes to the master
in a station.  Suppose the station component is a proxy point for 
a piece of data running in a Jace.  That causes a subscription over the
station-to-station connection resulting in the Jace's component to be
subscribed.  If the Jace component models an external device, that might
initiate a polling operation.  Keep in mind that n-tier subscribes might 
introduce delays.  The stale status bit is often used with subscription to 
indicate that a value hasn't yet been updated from an external device.
</p>

<p>
A component is moved into the subscribed state if any of the following are true:
</p>

<ul>

<li>If the component is running and any slot in the component is used as 
the source of an active link: <code>isRunning() && getKnobs().length > 0</code>.</li>

<li>There are one or more active 
<a href='module://docDeveloper/doc/baja-rt/javax/baja/sys/Subscriber.bajadoc'><code>Subscribers</code></a>.</li>

<li>The component is permanently subscribed via the <code>setPermanentlySubscribed()</code>
method.  A typical example is a control point with an extension that returns true for
<code>requiresPointSubscription()</code>.</li>

</ul>

<p>
Collectively these three cases are used by the framework to indicate
interest in a component.  The framework does not make a distinction between
how a component is subscribed, rather all three cases boil down to a simple
boolean condition: subscribed or unsubscribed.
</p>                                          

<p>
The <a href='module://docDeveloper/doc/baja-rt/javax/baja/sys/Subscriber.bajadoc'><code>Subscriber</code></a>
API is the standard mechanism to register for component events.  You can think
of Subscriber as the BComponent listener API.  Subscriber maintains a list of all
the components it is subscribed to, which makes cleanup easy via the 
<code>unsubscribeAll()</code> method.  Subscribers receive the <code>event()</code> 
callback for any component <a href='module://docDeveloper/doc/baja-rt/javax/baja/sys/BComponentEvent.bajadoc'>event</a> 
in their subscription list.  Note that workbench developers typically use
<a href='module://docDeveloper/doc/workbench-wb/javax/baja/workbench/view/BWbComponentView.bajadoc'><code>BWbComponentView</code></a>
which wraps the Subscriber API and provides automatic cleanup.
</p>

<!------------------------------------------------------------->
<h1 id="leasing">Leasing</h1>
<!------------------------------------------------------------->

<p>
A common need is to ensure that a component is synchronized, but 
only as a snapshot for immediate use.  The framework provides a feature
called <i>leasing</i> to handle this problem.  A lease is a temporary
subscription, typically for one minute.  After one minute, the component
automatically falls back to the unsubscribed state.  However, if the
component is leased again before the minute expires, then the lease time
is reset.
</p>

<p>
Leasing is accomplished via the <code>BComponent.lease()</code> method.
</p>

<!------------------------------------------------------------->
<h1 id="batchCalls">Batch Calls</h1>
<!------------------------------------------------------------->

<p>
Although the framework provides a nice abstraction for remote programming,
you must be cognizant that network calls are occurring under the covers and
that network calls are extremely expensive operations.  The number one cause
of performance problems is too many round robin network calls.  The golden
rule for remote programming is that one large batch network call is
almost always better performing than multiple small network calls.  Niagara 
provides APIs to batch many common operations.
</p>                         

<h2 id="batchResolve">Batch Resolve</h2>

<p>
The first opportunity to batch network calls is when resolving more than 
one ord to a component.  Resolving a component deep down in the tree for the 
first time requires loading the component and all it's ancestors across the 
network.  And if the ord is a handle ord, a network call is needed to translate 
the handle into a slot path.  The most efficient way to batch resolve is the via the 
<a href='module://docDeveloper/doc/baja-rt/javax/baja/naming/BatchResolve.bajadoc'><code>BatchResolve</code></a>
API.
</p>

<h2 id="batchSubscribe">Batch Subscribe</h2>

<p>     
Subscription is another key area to perform batch network calls.  There are 
three mechanisms for batch subscribe:
</p>

<ol>

<li>
The first mechanism is to subscribe using a depth.  The common case for 
subscription is when working with a subsection of the component tree.  
Depth based subscribe allows a component and a number of descendent levels 
to be subscribed via one operation.  For example if working with the children 
and grandchildren of a component, then subscribe with a depth of 2.  
</li>

<li>
On rare occasions you may need to subscribe to a set of components scattered 
across the database.  For this case there is a subscribe method that accepts 
an array of BComponents.  Both the Subscriber and BWbComponentView classes 
provide methods that accept a depth or an array.
</li>

<li>
The third mechanism for batch subscribe is do a batch lease.  Batch leasing
is accomplished via the static <code>BComponent.lease()</code> method.
</li>

</ol>

<h2 id="transactions">Transactions</h2>

<p>                 
By default, when making changes to a proxy component, each change is 
immediately marshaled over the network to the master.  However, if making 
many changes, then it is more efficient to batch these changes using  
<a href='module://docDeveloper/doc/baja-rt/javax/baja/sync/Transaction.bajadoc'><code>Transaction</code></a>.
Note most Transactions are used to batch a network call, but do not provide 
atomic commit capability like a RDBMS transaction. 
</p>

<p>
Transactions are passed as the Context to the various change methods like 
<code>set()</code> or <code>add()</code>.  Instead of committing the change,
the change is buffered up in the Transaction.  Note that Transaction implements
<a href='module://docDeveloper/doc/baja-rt/javax/baja/sys/Context.bajadoc'><code>Context</code></a>
and is a <a href='module://docDeveloper/doc/baja-rt/javax/baja/sync/SyncBuffer.bajadoc'><code>SyncBuffer</code></a>.
Refer to <a href='module://docDeveloper/doc/baja-rt/javax/baja/sync/Transaction.bajadoc'><code>Transaction's</code></a>
class header documentation for code examples.
</p>

<!------------------------------------------------------------->
<h1 id="debugging">Debugging</h1>
<!------------------------------------------------------------->

<p> 
The following provides some tips for debugging remote components:
</p> 

<p> 
The spy pages provide a wealth of information about both proxy and
master components including their subscribe state.  A component spy's 
page also contains information about why a component is subscribed
including the knobs and registered Subscribers.  Note that right clicking
a proxy component in the workbench causes a local lease, so it does
introduce a Heisenberg effect; one work around is to bookmark the spy
page to avoid right clicks.
</p>                      

<p>
The outstanding leases of a VM can be accessed via the 
<a href='local:|spy:/sysManagers/leaseManager'>LeaseManager</a>
spy page.
</p>

<p>
The most common performance problem is not batching up network calls.  The
mechanism for diagnosis is to turn on fox tracing.  Specially the "fox.broker"
log will illustrate network calls for loads, subscribes (sub), unsubscribes (unsub),
and proxy side changes (syncToMaster).  The simplest way to turn on this
tracing is <a href='local:|spy:/logSetup'>Log Setup</a> spy page.
</p>


<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/station.html" class="navbar">Prev</a> |  <a href="/doc/files.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
