<?xml version="1.0" encoding="UTF-8"?>
<bajadoc version="2.0" createdBy="niagara-baja-doclet-1.0.9" createdAt="03-May-2024" createdOn="883e7f7a9875">
<class module="bql" runtimeProfile="rt" qualifiedName="javax.baja.bql.BqlQuery" name="BqlQuery" packageName="javax.baja.bql" public="true" abstract="true">
<description>
BqlQuery is a query specified using the Baja Query Language.
</description>
<tag name="@author">John Sublett</tag>
<tag name="@creation">26 Mar 2002</tag>
<tag name="@version">$Revision: 15$ $Date: 6/24/10 3:13:25 PM EDT$</tag>
<tag name="@since">Baja 1.0</tag>
<extends>
<type class="java.lang.Object"/>
</extends>
<implements>
<type class="javax.baja.naming.OrdQuery"/>
</implements>
<!-- javax.baja.bql.BqlQuery() -->
<constructor name="BqlQuery" public="true">
<description/>
</constructor>

<!-- javax.baja.bql.BqlQuery.make(java.lang.String) -->
<method name="make"  public="true" static="true">
<description>
This is a factory method for creating a BQuery from BQL text.
</description>
<parameter name="bqlText">
<type class="java.lang.String"/>
</parameter>
<return>
<type class="javax.baja.bql.BqlQuery"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.make(java.lang.String, java.lang.String) -->
<method name="make"  public="true" static="true">
<description/>
<parameter name="scheme">
<type class="java.lang.String"/>
</parameter>
<parameter name="bqlText">
<type class="java.lang.String"/>
</parameter>
<return>
<type class="javax.baja.bql.BqlQuery"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.resolve(javax.baja.naming.OrdTarget) -->
<method name="resolve"  public="true" abstract="true">
<description>
Get the result of this query based on the specified base.
</description>
<parameter name="base">
<type class="javax.baja.naming.OrdTarget"/>
</parameter>
<return>
<type class="javax.baja.naming.OrdTarget"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.getScheme() -->
<method name="getScheme"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Get the ord scheme.
</description>
<return>
<type class="java.lang.String"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.getBody() -->
<method name="getBody"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Get the body text.
</description>
<return>
<type class="java.lang.String"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.getUnescaped() -->
<method name="getUnescaped"  public="true">
<description/>
<return>
<type class="java.lang.String"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.setBody(java.lang.String) -->
<method name="setBody"  protected="true">
<description/>
<parameter name="body">
<type class="java.lang.String"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.isHost() -->
<method name="isHost"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Return false.
</description>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.isSession() -->
<method name="isSession"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Return false.
</description>
<return>
<type class="boolean"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.normalize(javax.baja.naming.OrdQueryList, int) -->
<method name="normalize"  public="true">
<annotation><type class="java.lang.Override"/>
</annotation>
<description>
Normalization does not alter a BQL ord.
</description>
<parameter name="list">
<type class="javax.baja.naming.OrdQueryList"/>
</parameter>
<parameter name="index">
<type class="int"/>
</parameter>
<return>
<type class="void"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.toString() -->
<method name="toString"  public="true">
<description/>
<return>
<type class="java.lang.String"/>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.toBqlLiteral(javax.baja.sys.BSimple) -->
<method name="toBqlLiteral"  public="true" static="true">
<description>
Create a string representing the BQL literal for the given BSimple if it&#xa; were to be used in an expression in a bql query. The table below is just&#xa; meant to give some examples of expected output.&#xa; &lt;p&gt;&#xa; In BQL, simple types from the baja module do not need to be prefixed with&#xa; &#x22;baja:&#x22;, and this method will omit the baja prefix. &#xa; &lt;p&gt;&#xa; Also, the string encoding of the given BSimple will be escaped using&#xa; &lt;code&gt;<see ref="javax.baja.naming.SlotPath#escape(java.lang.String)">SlotPath.escape(String)</see>&lt;/code&gt;.&#xa; This means it is already valid for use in constructing a BOrd.&#xa; &#xa; &lt;p&gt;&#xa; &lt;table border=&#x27;1&#x27; summary=&#x22;BQL Literals for Simples and their shorthand equivalents&#x22;&gt;&#xa; &lt;tr&gt;&#xa; &lt;th align=&#x27;left&#x27;&gt;BSimple&lt;/th&gt;&#xa; &lt;th&gt;BQL Literal&lt;/th&gt;&#xa; &lt;th&gt;BQL Shorthand&#xa; &lt;/tr&gt;&#xa; &lt;tr&gt;&#xa; &lt;td&gt;&lt;code&gt;BLong.make(1)&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;Long &#x27;1&#x27;&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;1&lt;/code&gt;&#xa; &lt;/tr&gt;&#xa; &lt;tr&gt;&#xa; &lt;td&gt;&lt;code&gt;BAckState.acked&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;alarm:AckState &#x27;acked&#x27;&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;alarm:AckState.acked&lt;/code&gt;&lt;/td&gt;&#xa; &lt;/tr&gt;&#xa; &lt;tr&gt;&#xa; &lt;td&gt;&lt;code&gt;BUuid.make(&#x22;568aa62c-4f45-4287-be3c-b136e9bb8171&#x22;)&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;Uuid &#x27;568aa62c-4f45-4287-be3c-b136e9bb8171&#x27;&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;No shorthand supported; use bql literal.&lt;/td&gt;&#xa; &lt;/tr&gt;&#xa; &lt;tr&gt;&#xa; &lt;td&gt;&lt;code&gt;BOrdList.make(&#x22;local:|station:&#x22;)&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;&lt;code&gt;OrdList &#x27;local$3a$7cstation$3a&#x27;&lt;/code&gt;&lt;/td&gt;&#xa; &lt;td&gt;No shorthand supported; use bql literal.&lt;/td&gt;&#xa; &lt;/tr&gt;&#xa; &lt;/table&gt;&#xa; &lt;p&gt;&#xa; Note: In BQL, the string encoding of a BSimple is the value returned by&#xa; &lt;code&gt;s.encodeToString()&lt;/code&gt;. If this method throws an exception, then&#xa; &lt;code&gt;s.toString()&lt;/code&gt; will be used as the string encoding for the given&#xa; BSimple.
</description>
<tag name="@since">Niagara 3.5</tag>
<parameter name="s">
<type class="javax.baja.sys.BSimple"/>
<description>
the BSimple to encode to a BQL literal.
</description>
</parameter>
<return>
<type class="java.lang.String"/>
<description>
a String that is the BQL literal representation of the given&#xa;         BSimple. This value is already escaped and ready for use in&#xa;         constructing a BOrd.
</description>
</return>
</method>

<!-- javax.baja.bql.BqlQuery.scheme -->
<field name="scheme"  protected="true">
<type class="java.lang.String"/>
<description/>
</field>

</class>
</bajadoc>
