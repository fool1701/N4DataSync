<!-- Htmldoc has been run -->
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>
<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/hx-theming.html" class="navbar">Prev</a> |  <a href="/doc/themes/themingCustomWidgets.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.javascript-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.css-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<h1 id="theme-modules-overview">Theme Modules Overview</h1>
<p>This document will describe the parts of the UI that are available for theming, the general process of creating a theme module, as well as provide details and tips.</p>
<h1 id="niagara-4-ui-overview">Niagara 4 UI Overview</h1>
<h2 id="technologies">Technologies</h2>
<!-- TODO: Upgrade markdown language. For more advanced tables (like multi-line
cells, controlling column size, better word wrap and cell merging),
multimarkdown (http://fletcher.github.io/MultiMarkdown-5/tables.html) would be
nice. It also included automatic Table of Contents based on # Headers! -->
<table>
  <thead>
    <tr><th> </th><th> </th></tr>
  </thead>
  <tbody>
    <tr><td> <a href="#nss">bajaui</a> </td><td> The Java UI technology used heavily by Workbench to render things like the Workbench nav tree, Px widgets, and wizard dialogs. It is styled using files written in a Niagara-specific syntax called <em>NSS</em>. </td></tr>
    <tr><td> <a href="#javafx">JavaFX</a> </td><td> A UI technology that is distributed as part of Java 8 itself. It has a number of additional capabilities beyond what bajaui provides, like rounded corners and drop shadows. It is styled using a specialized set of CSS rules. In Niagara 4, Workbench uses JavaFX to render certain elements like toolbars and menu buttons. </td></tr>
    <tr><td> <a href="#hx">Hx</a> </td><td> A framework carried forward from Niagara AX. It runs in the station to generate web interfaces using HTML and JavaScript. </td></tr>
    <tr><td> <a href="#bajaux">bajaux</a> </td><td> A new framework in Niagara 4, based on HTML and JavaScript. It is used to create browser-based Niagara applications like Property Sheet, Web Chart, and User Manager. It is styled using pure CSS. </td></tr>
  </tbody>
</table>
<h2 id="theme-root-directory-structure"><a name="root"></a>Theme root directory structure</h2>
<table>
  <thead>
    <tr><th> <code>themeX/themeX-ux/</code> </th><th> Contents </th><th> Link </th></tr>
  </thead>
  <tbody>
    <tr><td> <code>src/fonts/</code> </td><td> Fonts </td><td> <a href="#fonts">Fonts</a> </td></tr>
    <tr><td> <code>src/fx/</code> </td><td> CSS used to style JavaFX elements of Workbench. </td><td> <a href="#javafx">JavaFX</a> </td></tr>
    <tr><td> <code>src/hx/</code> </td><td> CSS used to style Hx views. </td><td> <a href="#hx">Hx</a> </td></tr>
    <tr><td> <code>src/imageOverrides/</code> </td><td> Theme-specific replacements for icons from individual Niagara modules. </td><td> <a href="#icons">Icon Overriding</a> </td></tr>
    <tr><td> <code>src/nss/</code> </td><td> NSS files used to style Workbench. NSS syntax in 4.0 is exactly the same as in AX. </td><td> <a href="#nss">bajaui</a> </td></tr>
    <tr><td> <code>src/sprite/</code> </td><td> Spritesheet image and CSS file used to minimize the number of network calls necessary to retrieve icons in web-based views. </td><td> <a href="#sprites">Sprites</a> </td></tr>
    <tr><td> <code>src/ux/</code> </td><td> CSS used to style bajaux views, including the Shell Hx profile. </td><td> <a href="#bajaux">bajaux</a> </td></tr>
    <tr><td> <code>module-include.xml</code> </td><td> Used to identify the module as a theme module. </td><td> </td></tr>
    <tr><td> <code>themeX-ux.gradle</code> </td><td> Used to include the module in a build. </td><td> </td></tr>
  </tbody>
</table>
<h1 id="creating-a-theme-module">Creating a theme module</h1>
<p>Although it is possible to create a brand-new theme module from scratch, it is much easier to select an existing theme that comes closest to your desired look, then copy and make modifications to that theme. As part of this tutorial, we will use <code>themeZebra</code> as a basis for our new <code>themeOkapi</code> (we love our striped ungulate mammals here at Tridium).</p>
<p>The process of creating a theme module is very similar to creating any other Niagara module. The process outlined below will result in an exact copy of <code>themeZebra</code>, ready for modification.</p>
<ol>
  <li>
    <p>Create the folder structure for your module: <code>themeOkapi/themeOkapi-ux/</code>.</p>
  </li>
  <li>
    <p>Create a <code>src</code> directory in <code>themeOkapi-ux</code> and extract the contents of <code>themeZebra-ux.jar</code> into it.</p>
  </li>
  <li>
    <p>Move the following files from <code>src</code> into the root of <code>themeOkapi-ux</code>.</p>
    <ul>
      <li><code>cssTemplate.mustache</code></li>
      <li><code>Gruntfile.js</code></li>
      <li><code>package.json</code></li>
    </ul>
  </li>
  <li>
    <p>Delete <code>META-INF</code>.</p>
  </li>
  <li>
    <p>Ensure that any remaining references to <code>themeZebra</code> in these files are updated to reference <code>themeOkapi</code> instead.</p>
  </li>
  <li>
    <p>Create a <code>themeOkapi-ux.gradle</code> file:</p>
    <pre><code class="sunlight-highlight-plaintext">description = &quot;Tridium Zebra Okapi&quot;
niagaraModule {
  moduleName=&quot;themeOkapi&quot;
  preferredSymbol=&quot;toka&quot;
  runtimeProfile=&quot;ux&quot;
}
jar {
  from('src') {
    include 'fonts/'
    include 'fx/'
    include 'hx/'
    include 'imageOverrides/**/*.png'
    include 'less/**/*.*'
    include 'nss/'
    include 'sprite/'
    include 'ux/'
  }
  from ('.') {
    include 'cssTemplate.mustache'
    include 'Gruntfile.js'
    include 'package.json'
  }
}
</code></pre>
  </li>
  <li>
    <p>Create a <code>module-include.xml</code> file:</p>
    <pre><code class="sunlight-highlight-xml">&lt;defs&gt;
  &lt;def name=&quot;themeName&quot; value=&quot;themeOkapi&quot; /&gt;
&lt;/defs&gt;
</code></pre>
  </li>
  <li>
    <p>Final directory structure should resemble the Theme Root Directory Structure <a href="#root">above</a>.</p>
  </li>
  <li>
    <p>To build your theme, run</p>
    <pre><code class="sunlight-highlight-plaintext">gradlew :themeOkapi-ux:jar
</code></pre>
  </li>
  <li>
    <p>To select your theme, open Workbench, and Click Tools &gt; Options &gt; General &gt; Active Theme &gt; Okapi, then restart Workbench.</p>
  </li>
</ol>
<h1 id="styling-workbench">Styling Workbench</h1>
<!-- TODO: ## Anatomy of Workbench picture(s) that highlight the different parts
of Workbench, like menu bar, toolbar, etc.) -->
<h2 id="nss-styling-bajaui-elements-and-icons"><a name="nss"></a>NSS: Styling bajaui elements and icons</h2>
<h3 id="what-is-nss">What is NSS?</h3>
<p>NSS is <strong>not</strong> CSS. NSS only affects Workbench, not online content.</p>
<p>NSS (Niagara Style Sheets) is used to enable styling of fonts, colors, padding, and several other attributes on BWidgets and wiresheet Glyphs. Much like DOM components are styled by CSS, BWidgets and wiresheet Glyphs can be individually assigned style classes and style IDs. Styles can then be assigned to these classes/IDs rather than solely to widget types.</p>
<p>In its current form, NSS does not provide any information on how to paint a particular widget; it only provides details on what to paint. That is, given a widget with a certain type, style class, or ID, the NSS can tell you what font size, font color, background color, etc. that the widget should receive, but it is still up to the widget itself to do the actual painting. It is entirely possible to write a custom widget whose paint() method paints itself neon orange, regardless of what the theme might say.</p>
<h3 id="naming">Naming</h3>
<p>A theme <strong>requires</strong> at least one file with the extension <code>.nss</code> to work. If you have more than one, each <code>.nss</code> file can be individually selected as its own theme. That way, you can have several themes with different color schemes that share the same set of custom icons!</p>
<p>Unless using the default file name of <code>theme.nss</code>, the name of the <code>.nss</code> file itself will be used as the selectable display name. The word &ldquo;theme&rdquo; from your module name is automatically removed.</p>
<ul>
  <li>a file at ORD <code>module://themeTridium/nss/theme.nss</code> will show up as <code>Tridium</code></li>
  <li>a file at ORD <code>module://themeTridium/nss/OrangeAndPurple.nss</code> will show up as <code>Tridium/OrangeAndPurple</code></li>
</ul>
<h3 id="setting-a-default-theme-branding">Setting a Default Theme (Branding)</h3>
<p>It is possible to define a default theme for your brand by adding a line or two to <code>brand.properties</code>. Both lines are optional.</p>
<table>
  <thead>
    <tr><th> </th><th> </th></tr>
  </thead>
  <tbody>
    <tr><td> <code>workbench.theme.default</code> </td><td> Specifies the default theme for the current brand (Tridium uses &ldquo;Lucid&rdquo; by default). </td></tr>
    <tr><td> <code>workbench.theme.locked=true</code> </td><td> Locks the workstation into using the default theme. </td></tr>
  </tbody>
</table>
<h3 id="styling-with-the-px-editor">Styling with the PX editor</h3>
<p>When creating a button or label in the PX editor, there are three ways of assigning it fonts, colors, and such. You can&hellip;</p>
<ol>
  <li>Assign them directly to the widget using the widget&rsquo;s properties sheet.</li>
  <li>Create an external px property and link it to the widget.</li>
  <li>Leave the font/color set to &ldquo;Null/Default&rdquo; and allow the theme to do the painting.</li>
</ol>
<p>In the first two scenarios, NSS is completely ignored. Widget properties take precedent. In the case of a <a href="#custom-widgets">Custom Widget</a> written by an end user, it is up to the widget itself to decide whether or not to respect the theme.</p>
<h3 id="nss-file-syntax">NSS File Syntax</h3>
<p>Basic Example:</p>
<pre><code class="sunlight-highlight-css">// An NSS file is really just a set of key-value pairs. 
// The key is always a string. 

// The value can be a string: 
font: 12pt Tahoma;
color: black;

// ... or it can be another NSS node: 
button {
  color: blue;
}

.green-widget {
  color: green;
}

// This NSS file only really has five properties: font, color, button, label,
// and .green-widget. font and color refer to strings, while the others refer to
// NSS leaf nodes with properties of their own.

// NSS performs cascading, like CSS, but the syntax is different. All properties
// propagate down the NSS tree, explicitly using curly braces. As properties
// cascade, they are either inherited or overridden by leaf nodes lower in the
// tree. For instance, 'button' will inherit the Tahoma font of its parent, but
// will override the color with blue. However, a button that is assigned a style
// class of green-widget will inherit the green color of that class.

label {
  font: 12pt Arial;
  
  .big-label {
    font: 20pt monospaced;
  }
  // '.' denotes a class. 
  // 
  // Inheritance:
  //   A label with a style class of big-label will receive a font of 20pt
  //   monospaced. All other labels will receive a font of 12pt Arial.

  #red-label {
    color: red;
  }
  // '#' denotes an id. 
  // 
  // Inheritance:
  //   A label with a styleId of red-label will be colored red. 
  //   All other labels will be colored black.
  //
  //   id supersedes class. 
  //   .green-widget will be inherited by the label tag, meaning all labels with
  //   a style class of green-widget will be colored green except those with an
  //   ID of red-label, which will still be red.
}
</code></pre>
<p>Using #define:</p>
<pre><code class="sunlight-highlight-css">#define myFavoriteColor = green;

color: $myFavoriteColor;
background-color: $myFavoriteColor;
.disabled-color: $myFavoriteColor;

// NSS expands it out as if you had written
// color: green;
// background-color: green;
// .disabled-color: green;

// This allows you to control the value of many keys all from one place, keeping
// themes consistent, organized, and very easy to modify.

// You CANNOT nest #define variables in #define statements like so:
// #define foo = green;
// #define bar = $foo;
// background-color = $bar; 
// DOES NOT WORK.
</code></pre>
<h3 id="themescrollpane-and-themetexteditorpane">Theme.scrollPane() and Theme.textEditorPane()</h3>
<p>There is a bit of special behavior for Theme.scrollPane() since so many screens, in plat/platDaemon and elsewhere, rely on a certain bit of behavior left over from the original hardcoded Palladium theme. In order to use the background-color tag at pane scroll-pane background-color, use Theme.scrollPane().getWindowBackground() only. Using Theme.scrollPane().getControlBackground() will return the background-color property from the root of the NSS file.</p>
<p>The same applies to Theme.textEditorPane().</p>
<!-- TODO: ### What exactly does background-color | outline | shadow | highlight
do? 

If no background-color is selected, whatever is behind the element will show
through.

Outline, Shadow, and Highlight are all 1 px thick lines. Each one is independent
from the others, completely without overlap.

(Insert pictures of the different border effects.)
-->
<h2 id="javafx-styling-menus-and-toolbars"><a name="javafx"></a>JavaFX: Styling menus and toolbars</h2>
<p>In Niagara 4, the Java runtime has been upgraded from 1.4 to 1.8. Java 8 includes a UI framework called JavaFX, which includes a number of UI widgets which have been integrated into parts of Workbench.</p>
<p>JavaFX widgets are styled using a Java-specific dialect of CSS. A reference for JavaFX CSS is available here:</p>
<p><a href="https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html">https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html</a></p>
<p>NOTE: Oracle&rsquo;s documentation on JavaFX CSS seems to have a few omissions, like the <code>.context-menu</code> class. We&rsquo;ve already found a number of these missing classes and included them in the Zebra and Lucid themes.</p>
<p>Workbench widgets that can be styled using JavaFX include:</p>
<table>
  <thead>
    <tr><th> Workbench widget </th><th> corresponding JavaFX class name </th></tr>
  </thead>
  <tbody>
    <tr><td> menu bar </td><td> <code>menu</code>, <code>menu-item</code> </td></tr>
    <tr><td> toolbar </td><td> <code>tool-bar</code> </td></tr>
    <tr><td> scroll bars </td><td> <code>scroll-bar</code> </td></tr>
  </tbody>
</table>
<p>To style these widgets, place a CSS file in your theme module at <code>src/fx/theme.css</code>.</p>
<p>Some common IDs to use in your CSS will include the following. Additional selectors may be added in the future if more widgets are converted from <code>bajaui</code> to JavaFX.</p>
<table>
  <thead>
    <tr><th> JavaFX class name </th><th> target </th></tr>
  </thead>
  <tbody>
    <tr><td> <code>#menu-bar-profile</code><br><code>#menu-bar-profile-background-container</code><br><code>#menu-bar-profile-foreground-container</code>  </td><td> The topmost Workbench menu bar containing File, Edit, etc.<br>Foregrounds and backgrounds: primary areas of the UI are wrapped in two separate containers for advanced border and shadow effects. </td></tr>
    <tr><td> <code>#tool-bar-profile</code> </td><td> The topmost Workbench toolbar containing Back, Forwards, and Refresh buttons, etc. </td></tr>
    <tr><td> <code>#view-profile-foreground</code><br><code>#view-profile-background</code> </td><td> The pane containing the primary Workbench view, such as Property Sheet. </td></tr>
    <tr><td> <code>#content-profile-foreground</code><br><code>#content-profile-background</code> </td><td> The pane containing all Workbench content south of the location bar, including the main view, sidebars, and console. </td></tr>
  </tbody>
</table>
<p>Example:</p>
<p><img src="JavaFxIDs.png" alt="JavaFX CSS IDs" /></p>
<p>Niagara Framework &gt; Niagara 4 Theme Module Creation &gt; JavaFxIDs.png</p>
<pre><code class="sunlight-highlight-css">menu-bar-profile-background-container { -fx-background-color: red; }
menu-bar-profile-foreground-container { -fx-background-color: orange; }
view-profile-foreground { -fx-background-color: yellow; }
view-profile-background { -fx-background-color: green; }
content-profile-foreground { -fx-background-color: blue; }
content-profile-background { -fx-background-color: purple; }
</code></pre>
<p>NOTE: These background colors will show through any elements configured without a background color of their own.</p>
<h2 id="icon-overriding"><a name="icons"></a>Icon overriding</h2>
<p>The established way of obtaining an icon image is by calling <code>BImage.make(&quot;module://icons/path/to/my/icon.png&quot;)</code>. Other modules may contain their own icons, as well. For example, the alarm module has a few <code>.png</code> icons in <code>src/com/tridium/alarm/icons</code>.</p>
<p>A theme module can override these icons by simply adding an icon image with the same path and filename to the theme module&rsquo;s <code>/src/imageOverrides/&lt;module-name&gt;</code> directory. This icon will then take precedence over the version from the icons module.</p>
<p>NOTE: As with all non-code resources to be included in a module, the path to your overridden icons must be referenced in build.xml with a <resources> tag. Additionally, it is required that all override icons are the same dimensions as the icon being replaced. For instance, an icon that is 16 pixels in width and 16 pixels in height should be replaced by an image matching those dimensions.</p>
<p>Example 1: Overriding the Refresh button icon.</p>
<table>
  <thead>
    <tr><th> </th><th align="right"> </th></tr>
  </thead>
  <tbody>
    <tr><td> Image to override </td><td align="right"> ORD <code>module://icons/x16/refresh.png</code> </td></tr>
    <tr><td> Replacement image </td><td align="right"> <code>yourThemeModule/src/imageOverrides/icons/x16/refresh.png</code> </td></tr>
    <tr><td> build.xml entry </td><td align="right"> <code>&lt;resources name=&quot;imageOverrides/icons/x16/*.png&quot; /&gt;</code> </td></tr>
  </tbody>
</table>
<p>Example 2: Overriding filterRed.png in the alarm module - the icon that appears when you have a filter active on the Alarm Console view.</p>
<table>
  <thead>
    <tr><th> </th><th align="right"> </th></tr>
  </thead>
  <tbody>
    <tr><td> Image to override </td><td align="right"> ORD <code>module://alarm/com/tridium/alarm/icons/filterRed.png</code> </td></tr>
    <tr><td> Replacement image </td><td align="right"> <code>yourThemeModule/src/imageOverrides/alarm/com/tridium/alarm/icons/filterRed.png</code> </td></tr>
    <tr><td> build.xml entry </td><td align="right"> <code>&lt;resources name=&quot;imageOverrides/alarm/com/tridium/alarm/icons/*.png&quot; /&gt;</code> </td></tr>
  </tbody>
</table>
<p>TECH NOTE: The overriding takes place in com.tridium.gx.awt.ImageManager#load(ImageData, BOrd). The IconManager#getExistingOrd(BOrd) method checks the active theme first, then the default icons module, and finally returns error.png if not found in either place.</p>
<h2 id="fonts"><a name="fonts"></a>Fonts</h2>
<p>The default font in Niagara is sansserif, which allows the OS to display its own font. This helps improve the display in non-Windows systems.</p>
<p>In addition to defining styles and icons in a theme, it is also possible to embed fonts. Embedded fonts are automatically loaded with the theme and can be referenced by name in the Niagara Style Sheet.</p>
<p>To add fonts to a theme, place them in the <code>src\fonts</code> directory. Only True Type Fonts (ttf) are supported. The name referenced in the style sheet is <em>not</em> necessarily the same as the name of the file. Instead it is the name embedded in the font itself.</p>
<p>NOTE: when specifying a font in an NSS file, you must use the same format expected by a BFont or unexpected behavior may result.</p>
<h3 id="font-family-overrides">Font Family Overrides</h3>
<p>The best practice for defining fonts in a theme is to refer to them by font family, and then define what constitutes a font family by including a font-families tag in your NSS file. Like so:</p>
<pre><code class="sunlight-highlight-css">font-families {
  monospaced: Consolas, Courier New;
  sansserif: Tahoma, Helvetica, Arial;
  //serif, dialog, and dialoginput are also allowed
}

font: 12pt sansserif; 
// will paint with Tahoma (or Helvetica/Arial, depending on installed fonts)

button {
  font: 11pt monospaced; 
  // will paint with Consolas or Courier New
}
</code></pre>
<p>The available font families to specify are serif, sansserif, monospaced, dialog, and dialoginput. Each property in the font-families tag can take a comma-separated list of font names, and the NSS will settle on the first font in the list that your operating system has installed.</p>
<p>Using this method also allows you to override the font families using the bajaui lexicon. This way, if you have a language-specific lexicon, you can use it to select a font that explicitly supports that language. The fonts can be overridden using the bajaui lexicon like so:</p>
<pre><code class="sunlight-highlight-plaintext">font.monospaced=Consolas, Courier New
font.sansserif=Tahoma, Helvetica, Arial

# also font.serif, font.dialog, font.dialoginput
</code></pre>
<p>It is still entirely possible to hardcode a specific font, like font: 12pt Tahoma;. But as this will ignore the entries in the bajaui lexicon, this is not advised if you need support for international character sets.</p>
<h3 id="font-anti-aliasing">Font Anti-aliasing</h3>
<p>Font anti-aliasing is turned on by default for smoother display on LCD screens.</p>
<h1 id="styling-online">Styling Online</h1>
<h2 id="hx"><a name="hx"></a>Hx</h2>
<p><strong>Styling classic web views</strong></p>
<p>Hx views can now be styled on a per-theme basis. The CSS file should go in your theme module at <code>src/hx/theme.css</code>.</p>
<p>These styles will apply on top of the default Hx styles in <code>default.css</code>.</p>
<h2 id="bajaux"><a name="bajaux"></a>bajaux</h2>
<p><strong>Styling the new generation of Niagara web views</strong></p>
<p>bajaux views use a common list of CSS classes, intended to be overridden by themes and to make it easy to apply global styles to bajaux widgets.</p>
<p>The base set of CSS classes lives in the <code>web</code> module at <code>module://web/rc/theme/theme.css</code>. Most <code>bajaux</code> widgets can be styled using these classes. You can view a visual demonstration of the different classes available by going to:</p>
<p><a href="https://localhost/module/web/rc/theme/test.html?theme=Zebra">https://localhost/module/web/rc/theme/test.html?theme=Zebra</a> (replacing <code>localhost</code> with the address of your station, if needed).</p>
<p>In order to create a bajaux theme, you can simply redefine these CSS classes in <code>src/ux/theme.css</code>.</p>
<p><code>src/ux/theme.css</code> can also contain rules for any kind of <code>bajaux</code> widget, even those that might not use the base set of <code>ux</code> classes. There are several examples of this, which you can see in <code>themeZebra</code>&rsquo;s <code>src/ux/theme.css</code> file, including dialogs, Property Sheet, charts, and other widgets. At the moment, adding additional rules to <code>src/ux/theme.css</code> is the only way to style these widgets in a theme. Future releases may include additional functions to apply styles in a more modular way.</p>
<h2 id="less">LESS</h2>
<p><a href="http://lesscss.org/">LESS</a> is a CSS compiler that brings the power of variables, functions, mixins, math, and other tools to CSS.</p>
<p>Using our <code>themeZebra</code> template example, you will notice a folder <code>src/less/</code>, containing a number of <code>.less</code> files. One benefit of using LESS is that we&rsquo;ve chosen to store a base color palette in <code>palette.less</code>, so that they can be easily shared between the Hx and bajaux themes. In fact, you could simply change <code>palette.less</code> with no other changes, and instantly apply a new color scheme to both.</p>
<p>If you choose not to use LESS, you can simply edit <code>src/hx/theme.css</code> and <code>src/ux/theme.css</code> like any other CSS file. If you do want to give LESS a try, here are the steps you&rsquo;ll need to take:</p>
<ol>
  <li>
    <p>Install <a href="https://nodejs.org/">Node.js</a>.</p>
  </li>
  <li>
    <p>Install Grunt</p>
    <p>cmd&gt; <code>npm install -g grunt-cli</code></p>
  </li>
  <li>
    <p>Install PhantomJS</p>
    <p>cmd&gt; <code>npm install -g phantomjs</code></p>
  </li>
  <li>
    <p>From within your <code>themeX-ux</code> directory:</p>
    <p>cmd&gt; <code>npm install</code></p>
  </li>
  <li>
    <p>V1. To <strong>automatically</strong> compile changes whenever you save a <code>.less</code> file.</p>
    <p>From within your <code>themeX-ux</code> directory</p>
    <p>cmd&gt; <code>grunt watch:css</code></p>
    <p>Make your changes, hit reload in the browser, and immediately see those changes reflected in your Hx or <code>bajaux</code> views.</p>
  </li>
  <li>
    <p>V2. To do a <strong>one-time</strong> compilation:</p>
    <p>cmd&gt; <code>grunt less</code>.</p>
  </li>
</ol>
<h2 id="sprites"><a name="sprites"></a>Sprites</h2>
<p>In previous releases, icons were displayed simply by retrieving the individual icon files from the station and displaying them as img tags in the browser. On an embedded device, or with HTTPS turned on, minimizing the number of network calls becomes critical. So in the new Niagara 4 <code>bajaux</code> views, icons are now displayed using sprites.</p>
<p>A sprite is a number of different images, all concatenated together into one large image that forms a kind of mosaic. That large image is set as the background of an icon, but offset using CSS so that the particular icon you want is scrolled into view. The end result is that you can retrieve the entire icon set for a module using just two network calls: the sprite image, and the sprite CSS.</p>
<p>Due to this enhancement, if your theme module contains images, it <em>must</em> also contain a sprite. The sprite image should exist at <code>src/sprite/sprite.png</code> and the sprite CSS should be at <code>src/sprite/sprite.css</code>. You may generate your sprite using any tools you wish, but both <code>themeZebra</code> and <code>themeLucid</code> contain all the necessary configuration files to generate them for you. If you are using a stock theme as a base, you have everything you need.</p>
<p>A quick overview of the process follows.</p>
<ul>
  <li>The default Grunt task performs three different steps: <code>sprite</code>, <code>imagemin</code>, and <code>concat</code>. (Simply typing <code>grunt buildsprite</code> will do these three things in order.)
    <ol>
      <li>
        <p><code>grunt sprite</code> uses a utility called <code>spritesmith</code> to generate the sprite image and sprite CSS files. These both go in <code>src/sprite</code>.</p>
      </li>
      <li>
        <p><code>grunt imagemin</code> will losslessly compress <code>sprite.png</code> to save on space.</p>
      </li>
      <li>
        <p><code>grunt concat</code> adds the <code>@noSnoop</code> tag to the top of the CSS file.</p>
        <ul>
          <li>Tech details: this disables the <code>SnoopHtmlWriter</code> in the station, which would otherwise break the direct <code>url</code> references in <code>sprite.css</code>.)</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>
<p>NOTE: <code>themeZebra-ux</code> does not actually contain any image overrides. It relies completely on the contents of the default <code>icons-ux</code> module. So <code>themeZebra</code>&rsquo;s sprite will be empty. For an example of an actual generated sprite, try these steps with <code>themeLucid</code>.</p>
<h3 id="niagara-sprite-css-file-structure-and-how-to-load-into-a-theme">Niagara sprite CSS file structure, and how to load into a theme</h3>
<p>Each icon in a Niagara module, when packed into a sprite, will have its own specified CSS class referenced in <code>sprite.css</code>. Each will look something like this:</p>
<pre><code class="sunlight-highlight-css">.icon-icons-x16-add:before { 
  display: inline-block; 
  vertical-align: text-top; 
  content: ''; 
  background: url(/module/themeLucid/sprite/sprite.png) -180px -494px; 
  width: 16px; 
  height: 16px;
}

.icon-icons-x16-add &gt; img { 
  display: none; 
}
</code></pre>
<p>This follows certain conventions relating to sprites in Niagara apps.</p>
<p>First, the CSS class of the HTML icon element is derived from the ORD of the icon itself. It begins with <code>.icon</code> and matches the ORD starting with the module name and omitting the file extension.</p>
<p>Second, it has an additional CSS rule indicating that any <code>img</code> tags inside of it are to be hidden. Why this rule? Well, for <code>bajaux</code> to correctly generate the HTML for the icon, it needs to know whether the icon is already represented in the spritesheet or not. If it&rsquo;s already in <code>sprite.png</code>, it would make no sense to download the actual <code>add.png</code> on top of that. But if the icon is not in the sprite, it still needs to be displayed.</p>
<p>So, a dummy element will be added to the DOM offscreen. It will have both the CSS class <code>.icon-icons-x16-add</code>, and an <code>img</code> tag inside of it. If it&rsquo;s in <code>sprite.css</code>, that CSS rule will hide the <code>img</code> tag, and by checking the display CSS property of that <code>img</code> we&rsquo;ll know if it&rsquo;s in the sprite or not. Slightly clumsy, but it works.</p>
<p>The RequireJS module <code>bajaux/icon/iconUtils</code> handles all of this logic and will generate the appropriate icon HTML for you.</p>
<h2 id="theming-custom-widgets"><a name="custom-widgets"></a>Theming Custom Widgets</h2>
<p>To add styling to your custom built widgets, see the <a href="themingCustomWidgets.html">Theming Custom Widgets doc</a>.</p>
<h1 id="known-limitations">Known Limitations</h1>
<h2 id="incorporating-pre-made-widgets-to-stock-themes">Incorporating pre-made widgets to stock themes</h2>
<p>Say you have an HTML widget you&rsquo;ve already built, completely outside the context of Niagara or bajaux, and you wish to port it over as a <code>bajaux</code> widget. You might want to apply one set of CSS rules to your widget for the Zebra theme, and a different set for Lucid.</p>
<p>At the moment, there is no way to do this. You will have to change the HTML structure of your widget so that it uses the standard set of <code>ux</code> classes, or else it will appear the same in all the default themes.</p>
<p>You can still style the widget as you wish using your own custom theme.</p>
<h2 id="odds-and-ends-in-nss">Odds and Ends in NSS</h2>
<ul>
  <li>padding tags do not yet apply on a per-widget basis</li>
  <li>&ldquo;table font&rdquo; also affects dropdowns</li>
</ul>

<script type='text/javascript'>window.niagara.docDevUtil.highlightCode();</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/hx-theming.html" class="navbar">Prev</a> |  <a href="/doc/themes/themingCustomWidgets.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
