<!-- Htmldoc has been run -->
<!--
   @author    John Sublett
   @creation  17 Jan 05
   @version   $Revision$ $Date$
   @since     Niagara 3.0
 -->


<html>

<head>
<title>BQL</title>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>

<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/hierarchy.html" class="navbar">Prev</a> |  <a href="/doc/bqlExpressions.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<!-- Title Block -->
<h1 class='title'>BQL</h1>

<!------------------------------------------------------------->
<h1 id="introduction">Introduction</h1>
<!------------------------------------------------------------->

<p>
The Baja Query Language (BQL) is an SQL-like query language that
provides a mechanism for identifying various sets of data.  It provides
an ad hoc way to search for data based on some criteria.  By including
BQL in an ord, the results can be easily book marked or embedded in
graphics views.  This makes BQL an excellent tool for building reports.
</p>

<!------------------------------------------------------------->
<h1 id="select">Select</h1>
<!------------------------------------------------------------->

<p>
The select query is the most common type of BQL query.  It is
very similar to the select statement in SQL.  The syntax is as follows:
</p>

<pre>
  select &lt;projection&gt; from &lt;extent&gt; where &lt;predicate&gt; &lt;having&gt; &lt;order by&gt;
</pre>

<p>
The select statement always returns a table even if the result is actually a single object.
</p>

<h2>Extent</h2>

<p>
The first concept to understand about the above query is the extent.
The extent is specified in the "from" clause of the query.
The extent works together with the ord base to determine the general
set of objects in the result.  The rest of the query only narrows the
general result.  This is best explained with a few examples.
</p>

<pre>
  slot:/a/b/c|bql:select name, toString from control:ControlPoint
</pre>

<p>
In the above query, the base of the "bql" query is the "slot" query.
The slot scheme is used to access data in a Baja component tree.  In
this case, "slot:/a/b/c" identifies the root of the tree where the BQL
query processing will start.  From that point, the query will recursively
search the tree for components of type "control:ControlPoint".  So, when
the base of the "bql" query is a slot path, the path identifies the subtree
that will be searched by the query, and the extent identifies the type of component
to search for.  This query would get the name and toString for all control
points under the /a/b/c in the component tree.
</p>

<pre>
  history:|bql:select timestamp, value, status from /myStation/myHistory
</pre>

<p>
In this query, the base of the "bql" query is a "history" query.  The
history scheme is used to access data in the Baja history database.  In
this case, "history:" identifies the entire set of histories in the
database.  The query extent "/myStation/myHistory" identifies a specific
history in the database.  This query would get the timestamp, value, and
status of all records in the history with the id "/myStation/myHistory".
</p>

<h2>Projection</h2>

<p>
The projection is a comma separated list of the columns that will be
returned in the result.  Each element in the list must have a column
specification and may have a display name specified with the 'as'
clause.  Beginning in Niagara 3.5, columns may be arbitrary expressions.
The most frequent type of expression is a <a href='#bqlPaths'>path expression</a>,
but you can also call <a href='#functions'>scalar or aggregate functions</a>.
</p>

<pre>
  select name, toString from baja:Component
  select name as 'Point', out.value as 'Output Value', out.status from control:NumericPoint
  select MAX(out.value), MIN(out.value) from control:NumericPoint
  select (out.value * 100) + '%' as 'Percent' from control:NumericPoint
</pre>

<p>
In the second query, we know that all numeric points have an "out" property
that is a StatusValue.  A StatusValue is a structure that contains both a
status and a value.  In this query, we use a path to dive into the structure
and extract the value and status individually.
</p>

<p>
In the third query, we use two aggregate functions, MAX and MIN, to find the
largest and smallest value of all the control:ControlPoints in our query.  The
result will only have one row.  See the section on
<a href='#functions'>BQL functions</a> for more details
</p>

<p>
In the fourth query, we perform a calculation on the out.value to make it a
percent, and then append the '%' character to the result so that the column values
display with a percent sign.  The column name is aliased as 'Percent'.
</p>

<h2>Predicate</h2>

<p>
The predicate must be a boolean expression.  Its purpose is to apply criteria for
filtering objects out of the extent.  Look at this query:
</p>

<pre>
  history:|bql:select timestamp, value from /weatherStation/outsideAirTemp
</pre>

<p>
This query would retrieve the timestamp and value of all records in the
specified history.  That's often not a useful query and depending on how
long the history has been collected, it may return a lot more data than we
care to see.  Instead, let's find all records where the value exceeds
80 degrees.
</p>

<pre>
  history:|bql:select timestamp, value from /weatherStation/outsideAirTemp where value &gt; 80
</pre>

<p>
By adding the "where" clause with "value &gt; 80", all records with a value less than
80 are filtered out of the result.  To learn more about BQL expressions, see
<b><a href="bqlExpressions.html">BQL Expressions</a></b>.
</p>

<h2>Having</h2>

<p>The "having" clause must be a boolean expression. The having clause has
the same semantics as in SQL.  You can use the having clause to filter
the results of your query based on aggregate functions.  Consider this query:
</p>

<pre>
  select displayName, SUM(out.value) from control:NumericPoint having SUM(out.value) &gt; 100
</pre>

<p>
First, note that this query could return multiple rows since its projection
contains both scalar columns ("displayName") and aggregate columns ("SUM(out.value)").
Each row will contain a distinct displayName, and the SUM of all the "out.value"
values for the objects with that displayName.  The HAVING clause will further
restrict the result to only contain rows where the SUM of all the out.value values
is greater than 100.
</p>

<p>
Note that if the above query had only asked for "SUM(out.value)" and did not ask
for the displayName, there would only be one row in the result. It would contain
the SUM of all the "out.value" values regardless of the object's displayName. It would
not be very useful to include a HAVING clause in such a query.
</p>

<h2>Order By</h2>

<p>
The "order by" clause can be used to sort the results of the bql query.  It also
has similar semantics to SQL.  You can order by a path expression, a column
alias, or column position (using a 1-based index). Further, you can
specify whether you want the ordering to be done in ascending (ASC) or
descending (DESC) order.  ASC is assumed if not specified.  For example,
</p>

<pre>
  select displayName, slotPath as 'Path' from control:NumericPoint order by out.value, 1, 'Path' DESC
</pre>

<h2>Group By</h2>

<p>
BQL does not have a GROUP BY clause.  If you mention <i>ANY</i>
path expression in a query that contains aggregate functions, BQL implicitly
defines a distinct grouping based on all the unique path expressions in your
query.  Consider:
</p>

<pre>
  select displayName, MAX(out.value) from control:NumericPoint where isWritablePoint
</pre>

This query will cause the bql engine to define an implicit grouping based
on the "displayName" and "isWritablePoint" values.

<!------------------------------------------------------------->
<h1 id="simpleExpressions">Simple Expressions</h1>
<!------------------------------------------------------------->

<p>
In some cases, it may be desirable to fetch a single value instead of a table of objects.
You can can accomplish that with BQL by using a simple BQL expression.
</p>

<pre>
  slot:/a/b/c|bql:handle
</pre>

<p>
Putting a simple path expression in the BQL ord, causes the expression to be evaluated
relative to the base.  Resolving this ord just returns the value of the expression.  In
this case the result is the handle of the component identified by "/a/b/c".  Note: If
you run this query in Workbench, you will get a "No views are accessible" error since
the there are no views registered on the simple type "java.lang.String", which is the
type of the "handle" path expression.
</p>

<p>
Beginning in Niagara 3.5, you can evaluate multiple expressions against the base
and have the results returned in a table with a single row.
</p>

<pre>
  slot:/a/b/c|bql:{handle, out.value * 100, displayName + ' is my name'}
</pre>

<p>
Each of the expressions in the list is evaluated against the component at
"slot:/a/b/c".  The result is a table with a single row with the result
of evaluating each expression in its corresponding column.
</p>

<p>
Beginning in Niagara 3.6, you can alias the expressions.  The column for
that expression will have the alias as its display name in the resulting
table.

<pre>
  slot:/a/b/c|bql:{handle as 'h', out.value / 2 as 'half', displayName}
</pre>

</p>

<!------------------------------------------------------------->
<h1 id="bqlPaths">BQL Paths</h1>
<!------------------------------------------------------------->

<p>
BQL paths are an important element of any BQL query. A path can be used to
specify column content or to filter the rows in a query result. In all cases, a
path is relative to the set of objects defined by the extent.
</p>

<p>
A path is a dot-separated list of fields.  Consider the following example:
</p>

<pre>
  slot:/a/b|bql:select name, historyConfig.capacity from history:HistoryExt
</pre>

<p>
This retrieves the name and configured capacity of all history extensions under
"/a/b".  The extent tells me that I am only looking for history extensions.  The
second column specifier tells me to look inside the historyConfig and extract
the value of the "capacity" property.  The same concept can be applied in the
"where" clause.
</p>

<pre>
  slot:/a/b|bql:select name, out from control:NumericPoint where out.value &gt; 50
</pre>

<p>
In this case, the extent tells me that I am only looking for numeric points.
The where clause looks at the "value" property of the "out" property of each
numeric point in "/a/b" and only includes the ones that are greater than 50.
</p>

<p>
Presenting a list of all available fields in a path is not feasible.  The fields
that can be accessed in a path include all frozen and dynamic properties of
any component or struct (given sufficient security permissions) plus many of
the methods on the target type.  The Bajadoc reference is the best place to
find this information for a particular type.
</p>

<p>
A method is accessible via a path if it is public and returns a non-void value
and takes either no parameters or only a Context as a parameter. Methods that
match the "getX" pattern are handled specially.  To access a getter from BQL,
the "get" is dropped and the next letter is changed to lowercase resulting in
the name of the desired value rather than the method name for getting it.
</p>

<pre>
  getX -&gt; x
  getCurrentTemperature -&gt; currentTemperature
</pre>

<p>
A few methods are used particularly often.  "name" gets the slot name of a
value on its parent.  "parent" get the parent component.  "parent" is
useful because it allows you to look up the component tree.
</p>

<pre>
  slot:/foo/bar|bql:select parent.name, parent.slotPath from schedule:BooleanSchedule
</pre>

<p>
This query finds the name and path of all containers that contain a BooleanSchedule.
</p>

<p>
For more examples, see <a href="bqlExamples.html"><b>BQL Examples</b></a>.
</p>

<p>
For more information about expressions, see <a href="bqlExpressions.html"><b>BQL Expressions</b></a>.
</p>

<!------------------------------------------------------------->
<h1 id="functions">Scalar and Aggregate Functions</h1>
<!------------------------------------------------------------->

<p>
BQL supports two types of function expressions: 1) scalar functions and
2) aggregate functions.  Scalar functions operate on a single value and return
a single value. In this respect they are similar to path expressions.  Aggregate
functions operate on a set of values, and return a single, summarizing value.
BQL also supports the ability for programmers to create their own scalar and
aggregate functions.  In all cases, the syntax for calling a function is
</p>

<pre>
  (&lt;type spec&gt;.)&lt;function name&gt;(&lt;parameter list&gt;)
</pre>

<p>
The type spec is only required when the function is not part of the
built-in BQL library.  This is described in more detail in the sections below.
</p>

<h2>Scalar Functions</h2>

<p>
BQL provides the following built-in scalar functions
</p>
<ul>
<li>BBoolean slotExists(BString slotName): return true if an object has a slot with the given name.</li>
<li>BBoolean propertyExists(BString propName): return true if an object has a property with the given name.</li>
<li>BString substr(BString str, BNumber start, BNumber end): similar to Java substr() function.</li>
</ul>

<pre>
  select substr(displayName, 0, 1) from baja:Folder
  select slotPath, displayName from baja:Component where slotExists('out')
</pre>

<p>
The first query returns the first letter of all BFolders.  The second query
returns the slot path of every BComponent that has an 'out' slot.
</p>

<h3>User-defined Scalar Functions</h3>

<p>
In this example, we show how to create a new scalar function "strlen" that returns the
length of a BString. To create a new scalar function you simply define a new
<code>public static</code> method in one of your BObjects where the first
parameter is a BObject (the target object to work with), and the rest of the
parameters match the type of the parameters for your method.  The return type
of all BQL functions must be a BObject.
</p>

<pre>
  <code class="sunlight-highlight-java">
public BLib extends BObject {
  /** Define the strlen function */
  public static BInteger strlen(BObject target, BString str) {
    return BInteger.make(str.getString().length());
  }

  public static final Type TYPE = Sys.loadType(BBLib.class);
  public Type getType() { return TYPE; }
}
  </code>
</pre>

<p>
That's it! Pretty straight-forward.  Assuming this function was in a module
called "MyBql", here is how you could use it to get the displayName and its
length for every BFolder (note the use of the BTypeSpec to call the function):
</p>

<pre>
  select displayName, MyBql:Lib.strlen(displayName) from baja:Folder
</pre>

<h2>Aggregate Functions</h2>

<p>
BQL provides the following built-in aggregate functions:
</p>

<ol>
<li>COUNT(&lt;expresion&gt;): count the number of items in the result set. Supports
special syntax COUNT(*).</li>
<li>MAX(&lt;expression&gt;): evaluates the expression for every item in the result
set and returns the maximum value.  The expression must evaluate to a BNumber or BStatusNumeric.</li>
<li>MIN(&lt;expression&gt;): evaluates the expression for every item in the result
set and returns the minimum value.  The expression must evaluate to a BNumber or BStatusNumeric.</li>
<li>SUM(&lt;expression&gt;): evaluates the expression for every item in the result
set and returns the sum of all the values.  The expression must evaluate to a BNumber or BStatusNumeric.</li>
<li>AVG(&lt;expression&gt;): evaluates the expression for every item in the result
set and returns the average of all the values.  The expression must evaluate to a BNumber or BStatusNumeric.</li>
</ol>

<pre>
  select MAX(out), MIN(out), AVG(out), SUM(out) from control:NumericWritable
  select substr(displayName, 0, 1), COUNT(*) from baja:Folder
</pre>

<p>
The first query returns the max, min, average, and sum of all the out properties
of all control:NumericWritables.  The resulting table will have a single row
with four columns. The second query gets the first letter of every folder and then
counts how many folders start with that letter.
</p>

<h3>User-defined Aggregate Functions</h3>

<p>
<font color='red'>Note: The ability to create user-defined aggregate functions
is still considered experimental. The steps to create aggregate functions may
change in the future.</font>
</p>

<p>
In this example we show how to create and implement the AVG() aggregate function
provided by BQL.  Creating an aggregate function is a two-step process.  The process
is outlined below, and then a code example is provided.
</p>

<ul>
<li>Step 1: Create the aggregator class
	<ul>
	<li>Create a class that extends BObject and implements the "marker"
	javax.baja.bql.BIAggregator interface. This interface has no methods, it just
	serves to signal the BQL engine that the class has aggregator semantics.</li>
	<li>By convention, you must have a <code>public void</code> method called "aggregate"
	with a single parameter that is the type you want to aggregate on. This
	method will be called for each object in the result set. This is where the
	aggregating should be done.</li>
	<li>By convention, you must have a "public &lt;Type&gt;" method called "commit()"
	that returns the aggregate value.  This will be called on your class when all the
	objects have been aggregated.  This gives you a chance to do any further
	calculation before returning the result.</li>
	</ul>
</li>

<li>Step 2: Declare the aggregator in one of your module's classes so that BQl can find
it when given a BTypeSpec invocation of the aggregate function.
	<ul>
	<li>Declare a <code>public static final Type[] &lt;function name&gt;</code> in
	one of your module's classes.  The &lt;function name&gt; is the actual
	function name that would be used in a bql statement.  If you have multiple
	implementations of the aggregate function (perhaps to support different argument types), include
	them all in the array. The BQL engine will search the list of implementing
	classes until it finds one that implements an "aggregate(&lt;type&gt;)" method that matches
	the type of the current object.</li>
	</ul>
</li>
</ul>

<p>
Here is an implementation of AVG that supports averaging BNumbers and
BStatusNumerics.  This code example shows how to implement step 1 above.
</p>

<pre>
  <code class="sunlight-highlight-java">
public final class BAverage extends BObject implements BIAggregator {

  /** Aggregate a BNumber */
  public void aggregate(BNumber value) {
    ++count;
    sum += value.getDouble();
  }

  /** Only aggregates if the status is valid. Otherwise it is skipped */
  public void aggregate(BStatusNumeric value) {
    if (value.getStatus().isValid()) {
      ++count;
      sum += value.getValue();
    }
  }

  /** Calculate the average and return the result */
  public BDouble commit() {
    if (count == 0)
      return BDouble.NaN;
    else
      return BDouble.make(sum/count);
  }

  public static final Type TYPE = Sys.loadType(BAvg.class);
  public Type getType() { return TYPE; }

  private double sum;
  private long count;
}
  </code>
</pre>

<p>
In the scalar example above, we created a class "BLib" in the "MyBql" module
to create the "strlen()" function.  Here is how we can modify that class to
define the AVG function we just created.  This shows how to implement step 2
from the outline above.
</p>

<pre>
  <code class="sunlight-highlight-java">
public BLib extends BObject {
  /** Define the strlen function */
  public static BInteger strlen(BObject target, BString str) {
    return BInteger.make(str.getString().length());
  }

  // Declare the AVG aggregate function (step 2)
  public static final Type[] avg = { BAverage.TYPE };

  public static final Type TYPE = Sys.loadType(BBLib.class);
  public Type getType() { return TYPE; }
}
  </code>
</pre>

<p>
Note that the name of the aggregate function is determined by its declaration
in step 2, it is <b><i>NOT</i></b> the name of the class that implements
the aggregation logic.  Also, aggregate names are case-insensitive.  Here is
how you would call your implementation of the average aggregate function (note
the use of the BTypeSpec)
</p>

<pre>
  select MyBql:Lib.avg(out) from control:NumericWritable
</pre>

<!------------------------------------------------------------->
<h1 id="bqlFromJava">BQL from Java</h1>
<!------------------------------------------------------------->

<p>
BQL query results can easily be displayed in a table or chart in a user
interface. However, the results may also be examined in code using the Baja
API. The result of a "select" query is always a
<a href="module://docDeveloper/doc/baja-rt/javax/baja/collection/BITable.bajadoc">
  BITable</a>.  The items in the table depend on the query.  If
the projection is omitted, the result is a table of objects in the extent
that matched the predicate requirements.
</p>

<pre>
  <code class="sunlight-highlight-java">
  BOrd ord = BOrd.make("slot:/foo/bar|bql:select from control:NumericPoint");

  BITable result = (BITable)ord.resolve(base).get();
  Cursor c = result.cursor();
  double total = 0d;
  while (c.next())
  {
    total += ((BNumericPoint)c.get()).getOut().getValue();
  }
  </code>
</pre>

<p>
If the query has a projection, the result is a
<a href="module://docDeveloper/doc/baja-rt/javax/baja/collection/BITable.bajadoc">BITable</a>
and must be accessed that way to get the column data.
</p>

<pre>
  <code class="sunlight-highlight-java">
  BOrd ord = BOrd.make("slot:/foo/bar|bql:select name, out.value from control:NumericPoint");

  BITable result = (BITable)ord.resolve(base).get();
  ColumnList columns = result.getColumns();
  Column valueColumn = columns.get(1);
  TableCursor c = (TableCursor)result.cursor();
  double total = 0d;
  while (c.next())
  {
    total += ((BINumeric)c.get(valueColumn)).getNumeric();
  }
  </code>
</pre>

<p>
Since Niagara AX 3.5 you have been able to perform BQL queries against unmounted components.
This is useful when you are programmatically constructing component trees, and want
to query the tree structure, but the components are not mounted in a station or bog.
The example below illustrates how to do this.
</p>

<pre>
  <code class="sunlight-highlight-java">
   // NOTE: using setOut() for numeric writables because set() doesn't work when not mounted.
   BFolder folder = new BFolder();
   BNumericWritable nw1 = new BNumericWritable();
   nw1.setOut(new BStatusNumeric(50.0));
   folder.add("a", nw1);

   nw1 = new BNumericWritable();
   nw1.setOut(new BStatusNumeric(100.0));
   folder.add("b", nw1);

   String bql = "select sum(out.value) from control:NumericWritable";

   // Create the unmounted OrdTarget using new "unmounted" factory method
   OrdTarget target = OrdTarget.unmounted(folder);

   // Query the unmounted folder to get the sum of all children
   // control:NumericWritables out.value values.
   BITable coll = (BITable)BqlQuery.make(bql).resolve(target).get();
  </code>
</pre>
<script type="text/javascript">
    window.niagara.docDevUtil.highlightCode();
</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/hierarchy.html" class="navbar">Prev</a> |  <a href="/doc/bqlExpressions.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
