<!-- Htmldoc has been run -->
<!--
   @author    Brian Frank
   @creation  17 Jan 04
   @version   $Revision$ $Date$
   @since     Niagara 3.0
 -->

<html>

<head>
<title>PointDeviceExt</title>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>

<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/driverFramework.html" class="navbar">Prev</a> |  <a href="/doc/driverHistory.html" class="navbar">Next</a></p>


<!-- Header Navbar -->
<!-- Title Block -->
<h1 class='title'>PointDeviceExt Framework</h1>

<!------------------------------------------------------------->
<h1>Overview</h1>
<!------------------------------------------------------------->

<p>The <code><a href='module://docDeveloper/doc/driver-rt/javax/baja/driver/point/package-index.bajadoc'>javax.baja.driver.point</a></code>
API is used to perform point IO with logical or physical control points.
Drivers use the standard control points found in the
<code><a href='module://docDeveloper/doc/control-rt/module-index.bajadoc'>control</a></code> module.
But each driver provides a specialization of
<code><a href='module://docDeveloper/doc/driver-rt/javax/baja/driver/point/BProxyExt.bajadoc'>BProxyExt</a></code>
 for driver specific addressing, tuning, and IO.
</p>

<p>Refer to <a href='arch-driverHierarchy.html'>Architecture - Driver Hierarchy</a> for
an illustration of the component slot hierarchy.</p>

<p>Refer to <a href='arch-proxyExt.html'>Architecture - ProxyExt</a> for
an illustration of the design.</p>


<!------------------------------------------------------------->
<h1>Point Modes</h1>
<!------------------------------------------------------------->

<p>There are three modes which a proxy point may operate in:</p>

<ul>
<li><b>Readonly</b>:  These points are read from the device, but never written.</li>
<li><b>ReadWrite</b>:  These are points which the driver can both read from and write to.</li>
<li><b>Writeonly</b>:  These are points which the driver can write to, but cannot read. </li>
</ul>

<p>A ProxyExt must indicate which mode it is operating by overriding
the <code>getMode()</code> method</p>.

<!------------------------------------------------------------->
<h1>Proxy Ext</h1>
<!------------------------------------------------------------->

<p>
The <code>ProxyExt</code> component contains two properties used for
managing read and write values.
</p>

<p>
The <code>readValue</code> property indicates the last value read from the device.
For writeonly points this is the last value successfully written.  This value
is used to feed the parent point's extensions and out property.  If numeric,
it is in device units.
</p>


<p>
The <code>writeValue</code> property stores the value currently desired
to be written to the device.  If numeric, it is in device units.
</p>

<!------------------------------------------------------------->
<h1>Framework to Driver Callbacks</h1>
<!------------------------------------------------------------->

<p>Driver developers have three callbacks which should be used to
manage reads and writes:</p>

<ul>

<li><code>ProxyExt.readSubscribed()</code>:  This callback is made when
the point enters the subscribed state.  This is an indication to the driver
that something is now interested in this point.  Drivers should begin
polling or register for changes.
</li>

<li><code>ProxyExt.readUnsubscribed()</code>:  This callback is made when
the point enters the unsubscribed state.  This is an indication to the driver
that no one is interested in the point's current value anymore.  Drivers should
cease polling or unregister for changes.
</li>

<li><code>ProxyExt.write()</code>:  This callback is made when
the framework determines that a point should be written.  The tuning
policy is used to manage write scheduling.
</li>

</ul>

<p class='note'>
Note: All three callbacks should be handled quickly and should never
perform IO on the callers thread.  Instead drivers should use queues and
asynchronous threads to perform the actual IO.
</p>

<!------------------------------------------------------------->
<h1>Driver to Framework Callbacks</h1>
<!------------------------------------------------------------->

<p>The <code>ProxyExt</code> contains a standard API which the
driver should call once a read or write operation has been attempted.</p>

<p>If a read operation completes successfully then <code>readOk()</code>
method should be called with the value read.  If the read fails then
call the <code>readFail()</code> method.
</p>

<p>If a write operation completes successfully then the <code>writeOk()</code>
method should be called with the value written.  If the write fails
for any reason then call <code>writeFail()</code>.
</p>

<!------------------------------------------------------------->
<h1>Tuning</h1>
<!------------------------------------------------------------->

<p>All ProxyExts contain a Tuning property that manages how read
and writes are tuned.  All drivers which implement proxy points should create
a "tuningPolicies" property of type TuningPolicyMap on their DeviceNetwork.
The Tuning structure on each ProxyExt identifies its TuningPolicy within
the network by slot name.  TuningPolicies allow users to configure which state
transitions result in a <code>write()</code> callback.  TuningPolicies may
also be used to setup a minWriteTime to throttle writes and a maxWriteTime
to do rewrites.
</p>

<!------------------------------------------------------------->
<h1>Utilities</h1>
<!------------------------------------------------------------->

<p>The driver framework provides a suite of APIs to aid developers
in building their drivers:</p>

<ul>

<li><code><a href='module://docDeveloper/doc/driver-rt/javax/baja/driver/util/BPollScheduler.bajadoc'>BPollScheduler</a></code>:
This is a prebuild component that manages polling the points using a set of configurable
buckets.  To use this feature have your <code>ProxyExt</code> implement the
<code><a href='module://docDeveloper/doc/driver-rt/javax/baja/driver/util/BIPollable.bajadoc'>BIPollable</a></code> interface.</li>

<li><code><a href='module://docDeveloper/doc/nre-rt/javax/baja/nre/util/ByteBuffer.bajadoc'>ByteBuffer</a></code>:
This class provides a wealth of methods when working with byte buffers such as reading and
writing integers using big or little endian.</li>

</ul>


<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/driverFramework.html" class="navbar">Prev</a> |  <a href="/doc/driverHistory.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
