<!-- Htmldoc has been run -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Extending BGraphNode</title>
    <meta name="author" content="e452016" />
    <link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
    <!-- Date: 2012-05-22 -->
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
  </head>
  <body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/seriesTransforms/graphComponents.html" class="navbar">Prev</a> |  <a href="/doc/seriesTransforms/createTransformTable.html" class="navbar">Next</a></p>

  
  <script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
  <script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
  <script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>
  
  <h1>Extending the Graph Node</h1>
  <p>
    All graph node implementations must extend from BGraphNode. This base class provides several key 
    elements necessary to integrate with the transform graph. 
  </p>
  
  <!-- Properties -->
  <h2>Graph Properties</h2>
  <p>
    Each graph node includes 4 properties which are used by the transform graph as follows:
    <ul>
      <li>
        <p>
        <strong>Status</strong> <em>-</em> Provides the configuration status of the graph node. If the node is currently 
        misconfigured due to a change in the incoming <a href="nodeSchema.html">series schema</a> or node property settings made by 
        the end user, this status should be set to fault.
        </p>
      </li>
      <li>
        <p>
        <strong>faultCause</strong> <em>-</em> The fault cause provides a description of why the node is currently in a 
        fault state. This message should provide a description of what settings of the node are incorrectly 
        set to assist the end user in properly configuring your graph node within the transform graph.
        </p>
      </li>
      <li>
        <p>
        <strong>transformInputs</strong> <em>-</em> The transform inputs property is a target property to allow the 
        end user to connect one or more data input <a href="nodeSchema.html">schemas</a> to your graph node. 
        An input source will most often be the output of another graph node.
        </p>
        <p>
          This property defines the flow of data from a data source to a graph node and also defines the 
          structure of data that the graph node can expect when processing the data at graph resolve time.
        </p>
        <p>
          By default, this property does not declare the fanIn flag. You can set the fan in flag, or any 
          other flag, on this property in the constructor of your graph node using the following code snippet:
        </p>
        <pre>
          <code class="sunlight-highlight-java">
           Slot slot = getSlot(transformInputs.getName());
           if( null != slot)
              setFlags(slot, Flags.TRANSIENT|Flags.SUMMARY|Flags.FAN_IN);
           </code>
        </pre>
      </li>
      <li>
        <p>
        <strong>transformOutput</strong> <em>-</em> The transform output is a target property that allows an end 
        user to connect the output <a href="nodeSchema.html">schema</a> of the node as a data source to another node.
        </p>
      </li>
    </ul>
  </p>
  <p>
    While these 4 properties may not be overridden, a graph node implementation may include as many additional properties as desired. 
  </p>
  <p>
    Node properties should be thought of as <strong>design time</strong> configuration settings for the graph node. These settings will 
    be used at the time that the graph is resolved to determine how the incoming data for the node should be processed.
  </p>
  
  <!-- Abstract Methods-->
  <h2>Abstract Methods</h2>
  <p>
    When extending the BGraphNode base class, a handful of methods must be overridden and implemented.
  </p>
  
  <!-- getSchema-->
  <h3>getSchema(&nbsp;)</h3>
  <p>
    This method allows the node to return the expected output <a href="nodeSchema.html">data schema</a> of the 
    record object produced by the resolve time cursor. The schema is returned as a BSeriesSchema object.
  </p>
  <p>
    Returning the schema via method call rather than a property on the node allows 
    the schema to be built dynamically at the time the schema is requested based on the node configurations. 
  </p>
  
  <!-- doCheckSchema-->
  <h3>doCheckSchema(&nbsp;)</h3>
  <p>
    This method is called by the transform framework to allow the graph node to check the current incoming 
    <a href="nodeSchema.html">schema</a> 
    or schemas against its current outgoing schema configuration. In cases where the input schemas are no longer 
    sufficient to support the configuration of the output schema, a ConfigException should be thrown and the node 
    placed in fault to notify the end user that the node is currently misconfigured.
  </p>
  <p>
    This should be implemented by calling getSchema() on the source input nodes of the graph node and comparing 
    that input schema to the configurations of the graph node. If the graph node configurations are supported by 
    the incoming schemas we return from our method.
  </p>
  <p>
    Below is a snippet from the BScaleNode class that shows how the incoming schema is checked against the current scale 
    node configuration. What is important to node is that the method first retrieves all the input sources for the 
    node using the <strong>getSources()</strong> method of BGraphNode, then retrieves the schema for each input node 
    calling <strong>getSchema()</strong> on each source node. Each field of the schema that is used in the Scale Node&#39;s 
    configuration is then checked to ensure that the value represented by the schema field is a numeric type.
  </p>
  <pre>
    <code class="sunlight-highlight-java">
    //get the sources for our node by calling BGraphNode.getSources()
    BGraphNode[] sources = getSources();
  
    //get the configuration of our node. In the case of the Scale Node,
    //the configuration is stored as a collection of BScaleFactor 
    //objects. Each scale factor is a simple mapping of an incoming
    //schema field with a numeric scale factor.
    BScaleFactors scaleFactorContainer = getScaleFactors();
    Object[] factors =     
                   scaleFactorContainer.getChildren(BScaleFactor.class);
      
    //check if we have any sources 
    if( sources.length == 0)
    {
      //if we have factors but no sources, we are in fault
      if( factors.length > 0)
      {
        getTransformInputs().setStatus(BStatus.fault);
        getTransformInputs().setValue(
            lex.getText(SCHEMA_FAULT_UNMATCHED_FIELD));
      }
      return;
    }
      
    BGraphNode src = sources[0];
    src.lease();
    BSeriesSchema srcSchema = src.getSchema();
      
    // brute force check of all schema inputs to make sure that all our 
    // scale maps use schema values that are still present
    Set fields = getScaleInputFields();
    String keyField = srcSchema.getKeyField();
      
    for( int i = 0 ; i &lt; factors.length; i++)
    {
      BScaleFactor factor = (BScaleFactor)factors[i];
      String fieldName = factor.getInputFieldName();
        
      //ignore our key field
      if( fieldName.equals(keyField)) continue;
        
      //check that the incoming schema field exists in our set. If
      //the field is not present in our set of configured fields, 
      //throw an exception indicating that the schema does not 
      //correspond with our configuration.
      if( !fields.contains(fieldName) )
      {
        purge.add(factor);
        getTransformInputs().setStatus(BStatus.fault);
        getTransformInputs().setValue(
            lex.getText(SCHEMA_FAULT_INVALID_FIELD, 
            new Object[]{fieldName}));
          
        continue;
      }
        
      //check that the type value of the field is numeric
      BTypeSpec fieldType = srcSchema.getFieldType(fieldName);
      if( !fieldType.getTypeInfo().is(BINumeric.TYPE)){
          getTransformInputs().setStatus(BStatus.fault);
          getTransformInputs().setValue(
              lex.getText(SCHEMA_FAULT_INVALID_TYPE, 
                 new Object[]{
                         fieldType.toString(),
                         fieldName,
                         BScaleNode.TYPE.toString()
                  }
               )
           );
  
        continue;
      }
    }
    </code>
  </pre>
  
  <!-- doResolve method-->
  <h3>doResolve( BSeriesTransformTable[] , GraphNodeParams, BOrd )</h3>
  <p>
    This method is called when the graph node is resolved to a data cursor. This is the 
    method which brings together the Series Table defined for our graph node, the node 
    Cursor, and the configurations of the node itself.
  </p>
  <p>
    When this method is called, the graph node is expected to return an array of BSeriesTable 
    objects. This array will usually consist of one series table value.
  </p>
  <p>
    When creating the series table instance or instances to return, the method will use the 
    configuration data of the node to generate the table instance. This configuration data is 
    gathered in one of two ways in the following order:
  </p>
  <ol>
    <li>
      <p>
        The configuration data is obtained from the GraphNodeParams object passed into the method. 
        This object is map of the properties of the graph node to a value passed in at run time. 
        This value overrides the current property setting for this node.
      </p>
    </li>
    <li>
      <p>
        If no value is present for the property in the GraphNodeParams object, the value currently 
        set for the node property is used.
      </p>
    </li>
  </ol>
  <p>
    Below is a code snippet from the BHistorySourceNode class that demonstrates overriding the doResolve 
    method. Note that the GraphNodeParams object is first checked to see if it contains a value for the 
    given property name. If not, the value is obtained directly from our property.
  </p>
    <pre>
      <code class="sunlight-highlight-java">
      protected BSeriesTransformTable[] doResolve(
                         BSeriesTransformTable[] inputs,
                         GraphNodeParams args, 
                         BOrd base) throws TransformException
      {
           
          ...
        
        //Attempt to construct a history ORD from our node settings. First 
        //attempt to retrieve the value from our graph node args. If the
        //value is not present, return the value found in our graph node
        //property. 
        BOrd schemaOrd = BOrd.NULL;
        BFormat relativeSource = 
                 (BFormat)args.get(dataSource.getName(), getDataSource());
        BDynamicTimeRange range = (BDynamicTimeRange)args.get(dateRange.getName(), getDateRange());
          String historyOrdParams = getHistoryOrdParams(range);
          
          //construct our ORD from our format string and date range
      
        ...
      
        // If we have a source ORD, process the source
        if( schemaOrd != BOrd.DEFAULT )
        {
      
          //get our Ord Target
          BObject object = schemaOrd.get(base.get());
          if( object instanceof BICollection)
          {
            BICollection c = (BICollection)object;
      
            //create our quantization cursor for this source
            BITable table = c.toTable();
            BSeriesInterval interval = getQuantInterval();
            BSeriesTransformTable table;
            if( interval.getDesc() == BSeriesIntervalEnum.none)
            {
              table = new BNonQuantizedTable(getName(),
                                             getSchema(),
                                             table));
            }
            else
            {
               table = new BQuantizationTable( getName(),
                                               getSchema(),
                                               interval, 
                                               table) );
            }
      
            return new BSeriesTransformTable[]{table};
          }
      
        }
      
        //If we reach this point, we have an invalid data source
        throw new SourceException(INVALID_DATA_SRC);
      }
    </code>
  </pre>
  
  <script type="text/javascript">
    window.niagara.docDevUtil.highlightCode();
  </script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/seriesTransforms/graphComponents.html" class="navbar">Prev</a> |  <a href="/doc/seriesTransforms/createTransformTable.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
  </body>
</html>

