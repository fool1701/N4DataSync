<!-- Htmldoc has been run -->
<!--
   @author    Brian Frank
   @creation  13 Mar 02
              2 Feb 05  rework for categories
   @version   $Revision$ $Date$
   @since     Niagara 3.0
 -->

<html>

<head>
<title>Security</title>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>

<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/seriesTransforms/aggregateFunctions.html" class="navbar">Prev</a> |  <a href="/doc/security/securityManager.html" class="navbar">Next</a></p>


<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<!-- Title Block -->
<h1 class='title'>Security</h1>

<!------------------------------------------------------------->
<h1>Overview</h1>
<!------------------------------------------------------------->

<p>
Security in the Niagara framework covers a couple of broad topics:
</p>

<ul>
<li><b>Authentication</b>: Logging in and verifying a user;</li>
<li><b>Encryption</b>:  When and how to use cryptography to secure data;</li>
<li><b>Categories</b>: Categorizing objects we wish to protect via
the security model;</li>
<li><b>Permissions</b>: Configuring and verifying user permissions
on objects through categories;</li>
<li><b>Auditing</b>: Logging user actions to create an audit trail;</li>
</ul>

<p>
The following steps are used to setup a Niagara security model:
</p>

<ol>

<li>
First we have to define the users, which are modeled as BUsers.
</li>

<li>
We have to authenticate users, to make sure they are who they say
they are.  This is done via a login, with a username and password or
other credentials appropriate to the user's authentication scheme.
</li>

<li>
We have to determine what each user can do with each object.  The objects we
typically wish to protect are Components, Files, and Histories.  Each of
these objects is categorized into one or more categories.
</li>

<li>
We grant each user a set of permissions in each category.  This
defines exactly what each user can do with each object in the system.
</li>

<li>
Last we audit anything a user does for later analysis.
</li>

</ol>

<!---------------------------->
<h2>Users</h2>
<!---------------------------->

<p>
The <a href='module://docDeveloper/doc/baja-rt/javax/baja/user/BUser.bajadoc'>BUser</a>
component models security principles in a Niagara system.  Typically,
<code>BUsers</code> map to human users, but can also be used to represent
machine accounts for machine to machine logins.
</p>

<p>
The <a href='module://docDeveloper/doc/baja-rt/javax/baja/user/BUserService.bajadoc'>BUserService</a>
is used to store and lookup BUsers during login.  The <code>BUserService</code> simply stores the system users as
dynamic slots.
</p>

<p>
<code>BUser</code> is used to store the authentication credentials, roles, as well
as any other required meta-data for each user.  As a developer, if you wish
to add additional meta-data to users, then you might consider declaring your
own <a href='module://docDeveloper/doc/baja-rt/javax/baja/sys/BIMixIn.bajadoc'>BIMixIn</a>.
</p>

<!------------------------------------------------------------->
<h1>Authentication</h1>
<!------------------------------------------------------------->

<p>For a detailed look at the <code>BAuthenticationService</code>, and how to create new
<a href='module://docDeveloper/doc/baja-rt/javax/baja/authn/BAuthenticationScheme.bajadoc'>BAuthenticationSchemes</a>,
see the <a href="module://docDeveloper/doc/security/authentication.html">authentication documentation</a>.</p>

<p>All authentication in the Niagara framework is based on the
<a href='module://docDeveloper/doc/baja-rt/javax/baja/user/BUserService.bajadoc'>BUserService</a>
and the <code>BAuthenticationService</code> configured for a station database.</p>

<p>The <code>BAuthenticationService</code> determines what
<code>BAuthenticationSchemes</code>
a station supports. These <code>BAuthenticationSchemes</code> are then assigned to each user
in the <code>BUserService</code></p>

<p>The <code>BUserService</code> is used to lookup
<a href='module://docDeveloper/doc/baja-rt/javax/baja/user/BUser.bajadoc'>BUsers</a>
by username during login, to determine what <code>BAuthenticationScheme</code> to use.
This determines what types of credentials to acquire from the user, and how to acquire them.
The credentials are then compared to the credentials stored in the <code>BUserService</code>.

<p>There are three primary authentication points in the Niagara system:</p>

<ol>
<li><b>Fox Workbench to Station</b>: When a connection is made from workbench
to a station, the user is prompted for a username and credentials which
are used to authenticate the Fox connection.</li>
<li><b>Fox Station to Station</b>: When a connection is made from a
station to another station, preconfigured credentials are used
to authenticate the Fox connection.  These credentials are stored in
the <code>NiagaraStation.clientConnection</code> component.</li>
<li><b>HTTP Browser to Station</b>: When a browser hits a station URL,
an HTTP authentication mechanism is used to validate the user.</li>
</ol>

<!---------------------------->
<h2>Authentication and Communication Protocols</h2>
<!---------------------------->

<p>Niagara 4 supports authentication over fox and over HTTP. However, not all <code>BAuthenticationSchemes</code>
support both protocols. For example, the <code>HTTPBasicAuthenticationScheme</code> only works over HTTP. Pick a
<code>BAuthenticationScheme</code> appropriate for the user's requirements.</p>

<p>Details about what a <code>BAuthenticationScheme</code> needs to support authentication over fox
or HTTP are described in the <a href="module://docDeveloper/doc/security/authentication.html">authentication documentation</a>.</p>

<!------------------------------------------------------------->
<h1>Categories</h1>
<!------------------------------------------------------------->

<p>
All objects designed to be protected by the security model implement the
<a href='module://docDeveloper/doc/baja-rt/javax/baja/security/BIProtected.bajadoc'>BIProtected</a>
interface.  The <code>BIProtected</code> interface extends from the
<a href='module://docDeveloper/doc/baja-rt/javax/baja/category/BICategorizable.bajadoc'>BICategorizable</a>
interface.  An <code>ICategorizable</code> object has the ability to be assigned
to one or more categories.  In essence a category is just a number: Category 1,
Category 2, Category 3, etc.  You can give meaningful names categories by mapping
category numbers to a <a href='module://docDeveloper/doc/baja-rt/javax/baja/category/BCategory.bajadoc'>BCategory</a>
component within the <a href='module://docDeveloper/doc/baja-rt/javax/baja/category/BCategoryService.bajadoc'>BCategoryService</a>.
Most objects of interest implement the <code>BIProtected</code> interface including
<code>BComponent</code>, <code>BIFile</code>, and <code>BIHistory</code>.
</p>

<p>
Categories are just arbitrary groups - you can use categories
to model whatever your imagination dreams up.  Typically for security
they will map to some type of role, for example any device associated with
lighting may be assigned to a "lighting" category.  But that same device
may also be assigned to a "floor3" category.
</p>

<p>
Categories are implemented as variable length bit strings with
each bit representing a category number: bit 1 for Category 1, bit 2
for Category 2, etc.  This bit mask is encapsulated via the
<a href='module://docDeveloper/doc/baja-rt/javax/baja/category/BCategoryMask.bajadoc'>BCategoryMask</a>
class.  <code>CategoryMasks</code> are stored and displayed as hex strings,
for example the mask for membership in category 2 and 4 would be "a".  There
are two special <code>CategoryMasks</code>, the "" empty string represents
the <code>NULL</code> mask (membership in no categories) and "*" represents
the <code>WILDCARD</code> mask (membership in all categories).
</p>

<p>
The <code>BICategorizable</code> interface provides a <code>getCategoryMask()</code>
method to get the <i>configured category mask</i> for the object.  However most
objects support the notation of category inheritance, where the configured mask
is null and the applicable category mask is inherited from an ancestor.  This is
called the <i>applied category mask</i> and is accessed via the
<code>getAppliedCategoryMask()</code> method.
</p>

<!------------------------------------------------------------->
<h1>Permissions</h1>
<!------------------------------------------------------------->

<p>
Once a user has been authenticated, the user is granted or denied
permissions for each protected object in the system using the user's roles' configured
<a href='module://docDeveloper/doc/baja-rt/javax/baja/security/BPermissionsMap.bajadoc'>BPermissionsMap</a>.
This map grants the user permissions for each category, thereby
granting the user permissions for objects assigned to that category.  Users
may be configured as <i>super users</i> by setting their permissions map to
<code>BPermissionsMap.SUPER_USER</code>.  Super users are automatically
granted every permission in every category for every object.
</p>

<!---------------------------->
<h2>Permission Levels</h2>
<!---------------------------->

<p>Niagara defines two <i>permission levels</i> called <b>operator</b>
and <b>admin</b>.  Each slot in a BComponent is assigned to be operator
or admin based on whether the Flags.OPERATOR bit is set.</p>

<!---------------------------->
<h2>Permissions</h2>
<!---------------------------->

<p>
Each slot is defined as admin or operator level.  Six
<i>permissions</i> are derived to control access to slots:
</p>

<ul>
<li><b>Operator-Read</b>: Allows the user to view operator level information;</li>
<li><b>Operator-Write</b>: Allows the user to change operator level information;</li>
<li><b>Operator-Invoke</b>: Allows the user to view and invoke operator level operations;</li>
<li><b>Admin-Read</b>: Allows the user to view admin level information;</li>
<li><b>Admin-Write</b>: Allows the user to change admin level information;</li>
<li><b>Admin-Invoke</b>: Allows the user to view and invoke admin level operations;</li>
</ul>

<p>
The <a href='module://docDeveloper/doc/baja-rt/javax/baja/security/BPermissions.bajadoc'>BPermissions</a>
class is used to store a bitmask of these six permissions.
</p>

<!---------------------------->
<h2>Component Permission Semantics</h2>
<!---------------------------->

<p>The following are the standard semantics applied to <code>BComponents</code>:</p>

<table border='1'>
<tr><th>Operation</th><th>On Slot</th><th>Permission Required</th></tr>
<tr><td>read</td><td>operator non-BComponent properties</td><td>operatorRead</td></tr>
<tr><td>write</td><td>operator non-BComponent properties</td><td>operatorWrite</td></tr>
<tr><td>read</td><td>admin non-BComponent properties</td><td>adminRead</td></tr>
<tr><td>write</td><td>admin non-BComponent properties</td><td>adminWrite</td></tr>
<tr><td>read</td><td>operator BComponent properties</td><td>operatorRead on child</td></tr>
<tr><td>read</td><td>admin BComponent properties</td><td>operatorRead on child</td></tr>
<tr><td>invoke</td><td>operator actions</td><td>operatorInvoke</td></tr>
<tr><td>invoke</td><td>admin actions</td><td>adminInvoke</td></tr>
<tr><td>read</td><td>operator topics</td><td>operatorRead</td></tr>
<tr><td>read</td><td>admin topics</td><td>adminRead</td></tr>
</table>

<p>Note that the permissions required to access a property containing
a BComponent are based on the child BComponent regardless of access
to its parent or whether the containing slot is marked operator or
admin.</p>

<!---------------------------->
<h2>File Permission Semantics</h2>
<!---------------------------->

<p>
<code>BIFiles</code> use the operatorRead permissions to check read access
for the file and operatorWrite to check write access.  For a directory
operatorRead is required to list the directory, and operatorWrite to create
a new file.
</p>

<!---------------------------->
<h2>Computing Permissions</h2>
<!---------------------------->

<p>
To check the permissions available for a specific object use the
<code>BIProtected.getPermissions(Context)</code> method.  If working
with an <a href='module://docDeveloper/doc/baja-rt/javax/baja/naming/OrdTarget.bajadoc'>OrdTarget</a>,
then it is preferable to use <code>OrdTarget.getPermissionsForTarget()</code>,
which computes the permissions once and then caches the result.
</p>

<p>
The standard mechanism to compute permissions by an <code>IProtected</code>
object is:
</p>

<ol>

<li>If the Context is null or doesn't specify a user, then return
<code>BPermissions.all</code></li>

<li>Route to <code>BUser.getPermissionsFor()</code>.  Note: don't use this
method directly, because it might by-pass special cases within
<code>IProtected.getPermissionsFor()</code> (see below).</li>

<li>Get the object's mask using <code>getAppliedCategoryMask()</code>.</li>

<li>Map the category mask to a permissions mask via <code>BPermissionsMap.getPermissions(BCategoryMask)</code>,
which is a logical "OR" of each permission assigned to the configured categories.</li>

</ol>

<p>
There are a couple special cases to note.  First is that <code>BComponent</code>
access requires access to the entire ancestor tree.  For example to access "c"
in "/a/b/c", requires at least operatorRead access to "a" and "b".  The system
will automatically grant operatorRead to all ancestors of a component which
a user has at least one permission on.  Note that this calculation is only
done periodically, but can be forced using the <code>CategoryService.update</code>
action.
</p>

<p>
Another special case is <code>BIFile</code> which applies these special rules
for file system protection:
</p>

<ol>
<li>Files in a BModule are automatically granted operatorRead (this does not
include .class files which are never mapped into the ord name space).</li>
<li>If the user is not a super user, automatically deny any permissions outside
of the station home directory</li>
<li>Any remaining cases map to user's configured permissions via the file's
categories</li>
</ol>

<!---------------------------->
<h2>Checking Permissions</h2>
<!---------------------------->

<p>Permission checks are built-in at several layers of the framework:</p>

<ul>
<li>Checked on the BComponent modification methods.</li>
<li>Checked on all Fox network traffic.</li>
<li>Access in Workbench.</li>
</ul>

<p>Each of these checks is discussed in detail.</p>

<!---------------------------->
<h3>BComponent Modification</h3>
<!---------------------------->

<p>The following methods will check user permissions if
a non-null Context is passed with a non-null BUser.  If
the permission is not available then a PermissionException
is thrown.</p>

<ul>
<li><b>set():</b>  If the property is operator, then must have
operator write, otherwise admin write of the containing BComponent.</li>
<li><b>setFlags():</b>  Must have admin write of containing BComponent.</li>
<li><b>add():</b>  Must have admin write.</li>
<li><b>remove():</b>  Must have admin write.</li>
<li><b>rename():</b>  Must have admin write.</li>
<li><b>reorder():</b>  Must have admin write.</li>
<li><b>invoke():</b>  If the action is operator, then must have
operator invoke, otherwise admin invoke.</li>
</ul>

<p class='note'>Developers should take care to use the proper
version of the method with a user context when applicable.</p>

<!---------------------------->
<h3>Fox Traffic</h3>
<!---------------------------->

<p>Fox is the primary protocol used for workbench-to-station and
station-to-station communication.  Fox automatically performs all
permission checks on the server side before sensitive data can be
accessed or modified by a client.  By the time a BComponent reaches
the client Fox ensures the following:</p>

<ul>
<li>Dynamic slots which the user lacks permission to read are
never sent across the network and will never appear in the
client.</li>
<li>Frozen slots which is the user lacks permission to read/invoke
will automatically have the hidden flag set.</li>
<li>Frozen properties which the user lacks permission to write
will automatically have the readonly flag set.</li>
</ul>

<p>Furthermore all attempts to modify components are checked by
the server being committed.</p>

<!---------------------------->
<h3>Workbench Access</h3>
<!---------------------------->

<p>Each view declares the permissions a user is required to have on
a given BComponent in order to access the view.  These permissions
are usually declared in the module manifest (module-include).  By
default views require adminWrite.  To override the default:

<pre>
  <code class="sunlight-highlight-xml">
  &lt;type name="PropertySheet" class="com.tridium.workbench.propsheet.BPropertySheet"&gt;
    &lt;agent requiredPermissions="r"&gt;&lt;on type="baja:Component"/&gt;&lt;/agent&gt;&lt;/type&gt;
  </code>
</pre>

<p>
Note that required permissions for a dynamic <code>PxViews</code> are
configured via the <code>BPxView.requiredPermissions</code> property.
</p>

<!------------------------------------------------------------->
<h1>Auditing</h1>
<!------------------------------------------------------------->

<p>One of the important aspects of security is the ability to
analyze what has happened after the fact.  The Niagara component
model is designed to audit all property modifications and action
invocations.  Auditable actions include:</p>

<ul>
<li>Property changed</li>
<li>Property added</li>
<li>Property removed</li>
<li>Property renamed</li>
<li>Properties reordered</li>
<li>Action invoked</li>
</ul>

<p>Component modifications are only audited when the modification
method is passed a non-null Context with a non-null BUser.  The
history module includes a standard implementation of an audit trail
stored to a history database file.</p>

<!------------------------------------------------------------->
<h1>Code Samples</h1>
<!------------------------------------------------------------->

<p>In order to check if a BUser has a operator read permission on
specified component:</p>

<pre>
  <code class="sunlight-highlight-java">
target.getPermissionsFor(user).has(BPermissions.operatorRead) // BUser implements Context
  </code>
</pre>

<p>This snippet of code will throw a PermissionException if
the user lacks the admin invoke permission:</p>
<pre>
  <code class="sunlight-highlight-java">
user.check(target, BPermissions.adminInvoke)
  </code>
</pre>

<p>To filter a list of <code>INavNode</code> children for security:</p>
<pre>
  <code class="sunlight-highlight-java">
BINavNode[] kids = node.getNavChildren();
kids = BNavContainer.filter(kids, context);
  </code>
</pre>

<p>Use an AccessCursor to automatically skip slots that
a user lacks permission to read/invoke:</p>
<pre>
  <code class="sunlight-highlight-java">
SlotCursor c = AccessSlotCursor.make(target.getSlots(), user)
while(c.next()) {}
  </code>
</pre>

<script type="text/javascript">
    window.niagara.docDevUtil.highlightCode();
</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/seriesTransforms/aggregateFunctions.html" class="navbar">Prev</a> |  <a href="/doc/security/securityManager.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
