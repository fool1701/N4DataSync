<!-- Htmldoc has been run -->
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>
<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/jsdoc/webEditors-ux/index.html" class="navbar">Prev</a> |  <a href="/doc/jsdoc/webEditors-ux/tutorial-6-managers.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.javascript-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.css-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<h1 id="uxmedia">UxMedia</h1>
<h3 id="what-is-uxmedia">What is <code>UxMedia</code>?</h3>
<p><code>uxBuilder:UxMedia</code> is a type of Px media, new in Niagara 4.10. It marks a Px page as being fully supported, natively, in the browser, using only HTML5 and JavaScript.</p>
<p><code>UxMedia</code> differs from <code>Hx</code> in that <code>Hx</code> builds out the UI on the station using <code>bajaui</code> first, then using the <code>Hx</code> APIs, converts that UI to HTML and JavaScript strings to send to the browser. <code>UxMedia</code> is built completely upon <code>bajaux</code>, using BajaScript for data bindings. The entire UI is built out and rendered fully in the browser, not on the station.</p>
<h3 id="why-uxmedia">Why <code>UxMedia</code>?</h3>
<p>There were a number of motivations for creating <code>UxMedia</code>.</p>
<ol>
  <li><strong>Performance</strong>. <code>UxMedia</code> takes the hard work of rendering and layout, removes it from the JACE, and shifts it to the browser. JACEs are resource-constrained, so a device that is otherwise busy performing the work of communicating with and controlling physical devices may not have enough resources available to render a UI without encountering severe slowdowns. By allowing the user&rsquo;s own device to do the rendering work, it relieves some of the burden on the JACE itself.</li>
  <li><strong>Developer experience.</strong> By using the rich set of open-source tools available for JavaScript development, developing widgets for <code>UxMedia</code> is faster, easier, and provides immediate feedback. Using <code>grunt-niagara</code>, a rapid TDD cycle can be implemented, allowing for a comprehensive test suite with a high confidence in quality. Testing out changes to a <code>UxMedia</code> widget does not require a complete module rebuild and a station restart - just hit refresh in the browser to try out new behavior.</li>
  <li><strong>User experience.</strong> The first iteration of <code>UxMedia</code> attempts to retain the current behavior of the most commonly supported <code>bajaui</code> widgets. Moving forward, new widgets can be developed using current browser features and JavaScript APIs, allowing for a richer, smoother user experience.</li>
  <li><strong>Future growth.</strong> A UI that is native to HTML5 and JavaScript is more flexible and adaptable to future cloud-based solutions.</li>
</ol>
<h3 id="should-i-choose-uxmedia">Should I choose <code>UxMedia</code>?</h3>
<p>Consider the following before deciding whether to use <code>UxMedia</code>.</p>
<ul>
  <li><strong>Compatibility.</strong> <code>UxMedia</code> is brand new to Niagara 4.10, and not all widgets will be supported out of the box. Support for more and more widgets will be implemented in the future. You can try Audition Mode, described below, to see how well <code>UxMedia</code> works for your existing <code>Px</code> graphics.</li>
  <li><strong>Device Performance.</strong> <code>UxMedia</code> shifts much of the performance burden from the Station to your users&rsquo; devices. Consider the relative performance characteristics of both devices before choosing. If your users are using low-powered phones to communicate with a high-powered Supervisor, you won&rsquo;t see much of a performance boost. If your users are using modern devices with powerful processors to talk to a JACE that is under heavy load, then the performance increase could be substantial.</li>
  <li><strong>Widgets vs. Bindings.</strong> <code>UxMedia</code> shifts rendering and layout to the users&rsquo; devices, but the act of retrieving data for the Bindings will still require the station to do work. If your <code>Px</code> graphics have many Widgets and small, simple Bindings, you&rsquo;ll see more of a performance boost than if your graphic contains just a single Widget that does a long-running BQL query.</li>
  <li><strong>Development concerns.</strong> Tridium provides open-source tools and APIs intended to make the experience of developing <code>UxMedia</code> widgets easier and faster than ever before. But if you are heavily invested in your own custom <code>bajaui</code> widgets, it may not make sense to switch immediately. <code>bajaui</code> is still a well-supported API.</li>
  <li><strong>Future direction.</strong> Tridium is committed to providing support for web-native UIs, now and going forward. If you wish for your users&rsquo; experience to be as browser-native as possible, consider trying <code>UxMedia</code>.</li>
</ul>
<h3 id="how-can-i-use-uxmedia-as-a-px-page-designer">How can I use <code>UxMedia</code> as a <code>Px</code> page designer?</h3>
<p>Simply change the target media of your <code>Px</code> graphic to <code>uxBuilder:UxMedia</code>. Any widgets that do not have full <code>bajaux</code> implementations available will trigger a validation warning.</p>
<h4 id="audition-mode">Audition Mode</h4>
<p>In the HTML5 Hx Profile when you have the Web Profile option for &lsquo;Enable View Selection&rsquo; turned on, you will see an additional <code>Media Settings</code> Command in the toolbar when viewing a Px graphic. This allows an easy way to try out your existing <code>Px</code> graphics in Audition Mode to see how well they behave in <code>UxMedia</code>.</p>
<ul>
  <li>Stored Media Type: Set the target media type for the current <code>Px</code> graphic.</li>
  <li>Show Ux Media Preview: If true, the Stored Media Type will be readonly and pressing OK will show you a UxMedia Preview without changing the Stored Media Type.</li>
  <li>Audition Mode: allows for a quick and easy way to check every single graphic in the system. If true, two more &ldquo;back&rdquo; and &ldquo;forwards&rdquo; commands will appear, navigating you quickly to the previous or next <code>Px</code> graphic to see how it looks. If <code>Show Ux Media Preview</code> is checked, navigating using these commands will continue to show a UxMedia Preview.</li>
  <li>Audition Index: only used in Audition Mode. Allows you to navigate by index to the very first <code>Px</code> graphic found in the system (index 0), to the last one.</li>
  <li>Show Validation Warnings: set to true to display any validation warnings in the browser. Use this to determine exactly which widgets or bindings in your page are incompatible with <code>UxMedia</code>.</li>
</ul>
<p>As an alternative, you can set the system property <code>niagara.preferUxMedia=true</code>, which will display all <code>Px</code> pages in <code>UxMedia</code> in the browser, regardless of audition or media settings.</p>
<p>You can also hide the additional <code>Media Settings</code> command for all users by adding the system property <code>niagara.profile.hideMediaCommand=true</code>.</p>
<h4 id="opting-in-to-uxmedia">Opting in to <code>UxMedia</code></h4>
<p>For the first release, we are <em>not</em> making <code>UxMedia</code> the default. This is because it is still under Development status, and not all widgets and bindings are supported at first. But if you find it meets your needs and you would like to enable it across the board, we have provided a migration tool in the <code>pxEditor</code> palette, called <code>PxMediaMigration</code>.</p>
<p>This migration tool will allow you convert some or all of your <code>Px</code> graphics to <code>UxMedia</code>. Full documentation can be viewed <a href="uxMediaMigration.html">here</a>.</p>
<h4 id="supported-widgets">Supported Widgets</h4>
<p>This list is current as of September 29, 2020. It may not be comprehensive: widgets not in this list may also be supported in <code>UxMedia</code>. Test your pages in Audition Mode to make sure.</p>
<ul>
  <li><code>bajaui:Button</code></li>
  <li><code>bajaui:BorderPane</code></li>
  <li><code>bajaui:CanvasPane</code></li>
  <li><code>bajaui:CheckBox</code></li>
  <li><code>bajaui:ConstrainedPane</code></li>
  <li><code>bajaui:EdgePane</code></li>
  <li><code>bajaui:Ellipse</code></li>
  <li><code>bajaui:ExpandablePane</code></li>
  <li><code>bajaui:FlowPane</code></li>
  <li><code>bajaui:GridPane</code></li>
  <li><code>bajaui:HyperlinkLabel</code></li>
  <li><code>bajaui:Label</code></li>
  <li><code>bajaui:Line</code></li>
  <li><code>bajaui:Path</code></li>
  <li><code>bajaui:Picture</code></li>
  <li><code>bajaui:Polygon</code></li>
  <li><code>bajaui:PxInclude</code></li>
  <li><code>bajaui:RadioButton</code></li>
  <li><code>bajaui:Rect</code></li>
  <li><code>bajaui:ResponsivePane</code></li>
  <li><code>bajaui:ScrollPane</code></li>
  <li><code>bajaui:Separator</code></li>
  <li><code>bajaui:Slider</code></li>
  <li><code>bajaui:SplitPane</code></li>
  <li><code>bajaui:TabbedPane</code></li>
  <li><code>bajaui:ToggleButton</code></li>
  <li><code>bajaui:WebBrowser</code></li>
  <li><code>bajaui:WebWidget</code></li>
  <li><code>dashboard:DashboardPane</code></li>
  <li><code>kitPx:BackButton</code></li>
  <li><code>kitPx:Bargraph</code></li>
  <li><code>kitPx:BoundLabel</code></li>
  <li><code>kitPx:ForwardButton</code></li>
  <li><code>kitPx:GenericFieldEditor</code></li>
  <li><code>kitPx:ImageButton</code></li>
  <li><code>kitPx:LogoffButton</code></li>
  <li><code>kitPx:RefreshButton</code></li>
  <li><code>kitPx:SaveButton</code></li>
  <li><code>kitPx:SetPointFieldEditor</code></li>
  <li><code>report:ReportPane</code></li>
  <li><code>report:SectionHeader</code></li>
  <li><code>videoDriver:ControlPanel</code></li>
</ul>
<h3 id="deep-dive-how-can-i-use-uxmedia-as-a-programmer">Deep Dive: How can I use <code>UxMedia</code> as a programmer?</h3>
<p>Here is a quick listing of the different APIs required to develop for <code>UxMedia</code>. Some of these have been in use since the very first release of Niagara 4, while others are brand new in Niagara 4.10 specifically to support <code>UxMedia</code>. Please note that the new APIs are <strong>Development</strong> status and are subject to change.</p>
<h4 id="bajaux"><code>bajaux</code></h4>
<p>All <code>UxMedia</code> widgets are implemented with <code>bajaux</code>. Although <code>bajaux</code> itself has had only minimal changes Niagara 4.10, one new API may be of interest to you. <code>bajaux/spandrel</code> allows for easy declarations of entire trees of widgets and HTML elements, which will be used quite often in <code>UxMedia</code>. Please see the <code>bajaux</code> documentation for full details. If you decide <code>spandrel</code> is not right for you, your <code>UxMedia</code> widgets can be implemented using the same <code>bajaux</code> API as before.</p>
<h4 id="bajascript">BajaScript</h4>
<p>In <code>UxMedia</code>, data bindings and ORD resolutions are performed using BajaScript. Most of this should work out of the box, but if you have any custom Simple or Complex Types you <code>Px</code> graphics will need, you may want to consider using Type Extensions for the best experience. Please see the BajaScript documentation for full details.</p>
<h4 id="bijavascriptwidget"><code>BIJavaScriptWidget</code></h4>
<p>The same <code>BIJavaScript</code> agent registration mechanism used by regular <code>bajaux</code> views is still at play here. But for use in <code>UxMedia</code>, your classes may also need to implement <code>BIJavaScriptWidget</code> from the <code>web</code> module. This will mark your <code>bajaux</code> class as a <em>direct reimplementation</em> of an existing <code>bajaui</code> widget.</p>
<p>For instance, <code>BUxButton</code> implements <code>BIJavaScriptWidget</code> and is an agent on <code>BButton</code>. This marks <code>BUxButton</code> as a direct reimplementation to be swapped in whenever an instance of <code>BButton</code> is found in a Px graphic.</p>
<p>When implementing <code>BIJavaScriptWidget</code>, please take a look at the validation callback methods and implement them as needed. This will ensure that instances of your widget will correctly validate against <code>UxMedia</code>.</p>
<p>If you already have a Widget that implements <code>BIJavaScript</code>/<code>BIFormFactor</code> and is added to your Px page as a <code>workbench:WebWidget</code>, it will be supported as-is. There is no need to implement <code>BIJavaScriptWidget</code> in this case.</p>
<h4 id="binding"><code>Binding</code></h4>
<p>If you have implemented any custom Bindings, you will need to provide BajaScript-based analogs for use in <code>UxMedia</code>. These will need to be Type Extensions that extend the class <a href="../jsdoc/bajaui-ux/index.html"><code>nmodule/bajaui/rc/baja/binding/Binding</code></a>.</p>
<h4 id="converter"><code>Converter</code></h4>
<p>Same for any custom Converters you may have implemented. These will need to be Type Extensions that extend the class <a href="../jsdoc/converters-ux/index.html"><code>nmodule/converter/rc/Converter</code></a>.</p>
<h4 id="uxmodel"><code>UxModel</code></h4>
<p>Think of a <code>UxModel</code> as an analog of raw <code>Px</code> data, just transcribed to JSON form and given an API. It <em>describes</em> a tree of Widgets and Bindings, but does not actually <em>instantiate</em> them. Instead, it is used by Widgets whose child Widgets are user-configured in the Px data itself.</p>
<p>An example of a widget whose child Widgets are user-configured is CanvasPane. It has no inherent child widgets of its own. But if a user drags a Label from the palette onto the CanvasPane, it gets a new child widget. A Label, however, cannot have any user-configured child widgets of its own: if you drag something onto a Label, nothing happens. The Label is self-contained.</p>
<p>Therefore, when implementing <code>UxMedia</code> analogs of these widgets, our <code>CanvasPane</code> implementation will need to know about <code>UxModel</code>, because that&rsquo;s what lets <code>CanvasPane</code> know what its children are. A <code>UxMedia</code> <code>Label</code> doesn&rsquo;t need to care about <code>UxModel</code> because it has no children.</p>
<p>This will be much clearer if we look at a concrete example in the original <code>Px</code> and compare it to how it works in <code>UxMedia</code>.</p>
<h5 id="example-original-px">Example: Original Px</h5>
<p>For this example, imagine we created a <code>.px</code> file, set the root widget to a CanvasPane, and added a Label with the text &ldquo;Hello.&rdquo; We now have a <code>.px</code> file that looks like this simplified example:</p>
<pre><code>&lt;!-- myFile.px --&gt;
&lt;CanvasPane&gt;
  &lt;Label text=&quot;Hello&quot;/&gt;
&lt;/CanvasPane&gt;
</code></pre>
<p>I open this file in Workbench and sure enough, I see a CanvasPane with a Label on it that says Hello. How does this process work?</p>
<p>First, the <code>.px</code> file is parsed into a tree of <code>bajaui</code> widgets. A dedicated Px parser looks at the <code>.px</code> file and knows to execute code that looks something like this:</p>
<pre><code>BLabel label = new BLabel();
label.setText(&quot;hello&quot;);
BCanvasPane canvasPane = new BCanvasPane();
canvasPane.add(&quot;Label1&quot;, label);
</code></pre>
<p>We&rsquo;ve taken the <code>.px</code> file and parsed it out to a tree of <code>BWidget</code>s. The Px view itself will ask the CanvasPane to paint itself. How does the CanvasPane know to paint that child Label? Because it uses the Niagara component model, and the child Label shows up as a child slot!</p>
<pre><code>// in BCanvasPane.java
public void paint(Graphics g) {
  BWidget[] kids = getProperties(BWidget.TYPE);
  for (BWidget kid : kids) {
    kid.paint(g);
  }
} 
</code></pre>
<h5 id="example-uxmodel">Example: UxModel</h5>
<p>When you open this page in <code>UxMedia</code>, under the covers, it&rsquo;s going to make a request up to the station to get the contents of the <code>.px</code> page. The response will have all the same information as the <code>.px</code> file, but it will be restructured a bit to use JSON format. It will look something like the below - compare and contrast with the <code>Px</code> data in its original XML shown above.</p>
<pre><code>{
  type: CanvasPane,
  kids: [
    { 
      type: Label,
      properties: { text: 'Hello' }
    }
  ]
}
</code></pre>
<p>Now in the browser, that blob of JSON will be converted into a <code>UxModel</code> instance. It&rsquo;s all the same data, but has an API around it for ease of use. See the imaginary example below:</p>
<pre><code>return retrieveFromStation('myFile.px')
  .then((jsonBlob) =&gt; UxModel.make(jsonBlob))
  .then((uxModel) =&gt; {
    console.log(uxModel.getType()); // CanvasPane
    const [ labelModel ] = uxModel.getKids();
    console.log(labelModel.getType()); // Label
    console.log(labelModel.getProperties().text); // Hello
  });
</code></pre>
<p>Observe: the <code>UxModel</code> is the same data as the JSON blob, which is the same data as the <code>.px</code> file. It&rsquo;s not an actual tree of widgets - it&rsquo;s just data on <em>how</em> to create a tree of Widgets.</p>
<p>When the Px widget has child widgets, then your corresponding <code>bajaux</code> Widget will receive a <code>UxModel</code> instance that lets you know what those child widgets are. Your Widget can then instantiate them into child elements as it sees fit. As you might imagine, this is crucial behavior for Panes, because child widgets is all they are about! For other kinds of Widgets, not so much.</p>
<p>Here&rsquo;s how our simplified CanvasPane implementation might look:</p>
<pre><code>class CanvasPane extends spandrel((uxModel) =&gt; {
  return uxModel.getKids().map((kidModel) =&gt; {
    return kidModel.toSpandrel('&lt;div class=&quot;canvasPane-child&quot;/&gt;');
  });
}) {};
</code></pre>
<p>Here&rsquo;s a non-<code>spandrel</code> example. (Note that if the child widgets changed, or if one were added or removed, that additional work will have to be done: either wipe all the existing children and rebuild, or write code to diff the new widgets against the old. <code>spandrel</code>, if used, would do all this work for you.)</p>
<pre><code>class CanvasPane extends Widget {
  doLoad(uxModel) {
    return Promise.all(uxModel.getKids().map((kidModel) =&gt; {
      return fe.buildFor({
        dom: $('&lt;div class=&quot;canvasPane-child&quot;/&gt;').appendTo(this.jq()),
        type: kidModel.getType(),
        properties: kidModel.getProperties()
        // readonly, enabled, formFactor...
      });
    }));
  }
}
</code></pre>
<p>Put it side by side:</p>
<ul>
  <li>In <code>bajaui</code> world, the <code>BCanvasPane</code> knows to render a child <code>BLabel</code> because <code>BCanvasPane</code> is a <code>BComponent</code> and the <code>BLabel</code> shows up as a child Property.</li>
  <li>In <code>UxMedia</code> world, the <code>CanvasPane</code> knows to render a child <code>Label</code> because the <code>Label</code> shows up as a child of the <code>UxModel</code> that gets passed to <code>doLoad()</code>.</li>
</ul>
<p>If your <code>UxMedia</code> widget does not need to make use of a <code>UxModel</code>, only remember that it will still receive a <code>UxModel</code> instance when its <code>load()</code> method is called - you&rsquo;re just free to ignore it if it&rsquo;s not needed.</p>
<h4 id="styling-with-css">Styling with CSS</h4>
<p>If you spin up a <code>UxMedia</code> page and inspect the DOM, you&rsquo;ll see a number of CSS classes in use. This section will describe some of the CSS conventions we are following in <code>UxMedia</code>.</p>
<p>When you see a CSS class that looks like <code>ux-Widget</code> - for instance, <code>ux-Label</code> or <code>ux-TabbedPane</code> - that CSS class identifies an element in which a <code>UxMedia</code> widget lives. You can call <code>Widget.in()</code> on these elements, and a <code>Label</code>, <code>TabbedPane</code>, etc. will come out. You can rely on this behavior.</p>
<p>When you see a class that looks like <code>ux-Widget-style</code> - for instance, <code>ux-Label-content</code> or <code>ux-TabbedPane-tabs</code> - it indicates a child element that can be styled externally. If you have a custom Niagara theme, and you wish to apply themed styles to <code>UxMedia</code> widgets, you can target these classes for styling. This behavior is mostly safe to use, in that we will try to minimize changes to these classes. Until <code>UxMedia</code> is out of Development status, there may still be some changes from version to version. Note that the first letter after <code>ux-</code> is uppercase.</p>
<p>When you see a class that looks like <code>-t-Widget-style</code> - for instance, <code>-t-Label-text</code> or <code>-t-TabbedPane-content</code> - it indicates style rules considered to be &ldquo;private&rdquo;. (The <code>-t-</code> stands for Tridium.). They are always subject to change, so you should not rely on these classes remaining consistent from version to version.</p>
<p>Classes that are not specific to <code>UxMedia</code> are described below:</p>
<p>When you see a class that looks like <code>ux-some-rule</code> - for instance, <code>ux-btn</code> or <code>ux-root</code> - those classes are typically the standard classes applied for theming purposes, not just for <code>UxMedia</code> but across Niagara&rsquo;s entire <code>bajaux</code> UI. Note that the first letter after <code>ux-</code> is lowercase. You can visit a test page in a running station by visiting <code>/module/web/rc/theme/test.html</code> to learn more about these classes. You may see a few other classes that are not covered in the theme which are used for JavaScript rather than styling.</p>
<p>When you see a class that begins with <code>bajaux-</code>, those are native to <code>bajaux</code> itself and are not typically used for styling purposes. You can find these classes described in the <a href="../jsdoc/module-bajaux_Widget.html#.css__anchor">Widget</a> documentation.</p>
<h3 id="performance-notes">Performance Notes</h3>
<p>As stated before, performance is one of the primary motivations for creating <code>UxMedia</code>. We are eager to hear about your real-world use cases and whether you see performance gains, losses, or no changes at all. If you give an audition to <code>UxMedia</code>, please consider reaching out through your tech support channel, sales rep, or the Niagara Community Forums and let us know your experiences.</p>
<p>We want to make your experience with <code>UxMedia</code> the very best it can be.</p>
<p>Thanks for reading!</p>

<script type='text/javascript'>window.niagara.docDevUtil.highlightCode();</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/jsdoc/webEditors-ux/index.html" class="navbar">Prev</a> |  <a href="/doc/jsdoc/webEditors-ux/tutorial-6-managers.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
