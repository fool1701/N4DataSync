<!-- Htmldoc has been run -->
<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='module://docDeveloper/rc/sunlight.default.css'>
<!-- Auto-generated style sheet link --><link rel='StyleSheet' href='module://bajaui/doc/style.css' type='text/css' />
<!-- Auto-generated js link for Activity Monitoring --><script type='text/javascript' src='module://web/rc/util/activityMonitor.js'></script>
<script type='text/javascript'>window.addEventListener('load', activityMonitor.start);</script>
</head>
<body>
<!-- Auto-generated Header NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/uiFromAxToN4.html" class="navbar">Prev</a> |  <a href="/doc/servingFromFileSys.html" class="navbar">Next</a></p>

<script type='text/javascript' src='module://docDeveloper/rc/sunlight-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.java-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.javascript-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.xml-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/sunlight.css-min.js'></script>
<script type='text/javascript' src='module://docDeveloper/rc/niagara-sunlight-support.js'></script>

<h1 id="ui-changelog">UI Changelog</h1>
<p>This file will document notable API changes specific to the Niagara UI. Hard breaking changes will always be documented on their own, but other notable non-breaking changes are worthy of their own description.</p>
<h2 id="niagara-413">Niagara 4.13</h2>
<h3 id="instantiated-hook-parameter-respected-by-widgetmanager"><code>instantiated</code> hook parameter respected by <code>WidgetManager</code></h3>
<p>Previously, only a global <code>instantiated</code> hook, installed by calling <code>installHooks()</code>, would be respected when using a <code>WidgetManager</code> (such as with <code>fe.buildFor</code>). Now, a passed <code>hooks.instantiated</code> parameter will also be respected.</p>
<h3 id="bajascript-rpc-calls-returning-complex-now-bson-marshal-them">BajaScript RPC calls returning Complex now BSON-marshal them</h3>
<p>When calling an RPC via BOX (e.g. using <code>baja.rpc()</code>), if the response was a <code>BComplex</code>, the client would just receive a <code>toString</code> of it, which was not useful. Now, the response will be a BSON-encoded representation of that <code>BComplex</code>, which can be decoded in the client using <code>baja.bson.decodeAsync()</code>.</p>
<h3 id="spandrel-bugs-fixed"><code>spandrel</code> bugs fixed</h3>
<ul>
  <li>When a child widget both 1) changes properties, readonly, or enabled, and 2) loads a new value at the same time, the new value load could sometimes get lost. Now all these changes will be correctly applied to child widgets.</li>
  <li>When <code>read()</code>ing a <code>spandrel</code> widget&rsquo;s current value, it will correctly wait for any pending <code>load()</code> or state propagation to complete first.</li>
  <li>When a child is removed, remaining children will have their <code>spandrelKey</code>s correctly updated so additional removes will target the right children.</li>
  <li>Calling <code>queryWidget</code> or <code>queryWidgets</code> after the widget is already destroyed will just return an empty array, not throw an error.</li>
  <li>The <code>inherit</code> keyword for properties/readonly/enabled now correctly inherits from the owner widget, not the immediate parent.</li>
  <li>When a child widget has configured event handlers, its place in the set of children can now be replaced with a falsy value without causing the rerender to fail.</li>
</ul>
<h3 id="widget-stricter-about-initialization-complete"><code>Widget</code> stricter about initialization complete</h3>
<p>Previously, <code>Widget#load</code> would still resolve as long as <code>initialize()</code> had been called, even if it hadn&rsquo;t completed. This means that code that looks like this:</p>
<pre><code class="jsx">widget.initialize(dom);
return widget.load('my value'); // initialization isn't finished yet!
</code></pre>
<p>may have succeeded sometimes, or failed sometimes. Now, <code>load()</code> will reject if <code>initialize()</code> has not yet completed. If you experience new failures, be sure that initialization is complete before loading a new value:</p>
<pre><code class="jsx">return widget.initialize(dom)
  .then(() =&gt; widget.load('my value'));
</code></pre>
<p>In addition, <code>isInitialized()</code> will now return false until the <code>initialize()</code> promise has resolved. In other words, the previous behavior was:</p>
<pre><code class="jsx">widget.initialize(dom);
widget.isInitialized(); // true
</code></pre>
<p>The new behavior is:</p>
<pre><code class="jsx">const promise = widget.initialize(dom);
widget.isInitialized(); // false
return promise.then(() =&gt; {
  widget.isInitialized(); // true
});
</code></pre>
<p>Because the <code>doChanged()</code> callback (called when a <code>Widget</code> <code>Property</code> changes) does not run until <code>isInitialized()</code> returns <code>true</code>, this means that <code>doChanged()</code> will also not be called until the <code>initialize()</code> promise fully resolves. An example of the old behavior is:</p>
<pre><code class="jsx">widget.doChanged = (name, value) =&gt; console.log(name + ' is now ' + value);
widget.initialize(dom);
widget.properties().add('a', 'b'); // this fires doChanged and logs to the console
</code></pre>
<p>The new behavior requires <code>initialize()</code> to finish:</p>
<pre><code class="jsx">widget.doChanged = (name, value) =&gt; console.log(name + ' is now ' + value);

const promise = widget.initialize(dom);
widget.properties.add('a', 'b'); // does _not_ fire doChanged or log to the console

return promise.then(() =&gt; {
  widget.properties().add('c', 'd'); // _now_ doChanged will get fired
});
</code></pre>
<h3 id="biwebresource-introduced"><code>BIWebResource</code> introduced</h3>
<p><code>BIWebResource</code> solves two problems.</p>
<h4 id="redundant-css-declarations">Redundant CSS declarations</h4>
<p>JavaScript resources, such as bajaux field editors, often depend on CSS rules to work properly. They can declare their own dependencies on CSS files using the <code>css!</code> RequireJs plugin, but it&rsquo;s easy to forget to do this. It&rsquo;s also redundant - usually a Niagara module will only have one CSS file, and manually adding <code>css!nmodule/myModule/rc/myModule</code> as a dependency to every field editor in a module is a chore.</p>
<p><code>BCssResource</code>, an implementation of <code>BIWebResource</code>, solves this. It&rsquo;s now possible to declare a <code>BJsBuild</code> (which all your field editors must reference anyway) as having a dependency on a CSS file. This way, the framework will ensure that the proper CSS files are loaded whenever a <code>BIJavaScript</code> that uses that <code>BJsBuild</code> is instantiated in the browser.</p>
<h4 id="interdependencies-between-builtfiles">Interdependencies between builtfiles</h4>
<p>When resolving dependencies of <code>BIJavaScript</code> objects (like bajaux field editors or BajaScript type extensions), we previously resolved them as a flat list of dependencies.</p>
<pre><code class="jsx">const deps = [ 'bajaux/rc/bajaux.built.min', 'nmodule/webEditors/rc/webEditors.built.min' ];
const requireJsId = 'nmodule/webEditors/rc/fe/baja/StringEditor';

require(deps, function () {
  require([ requireJsId ], function (resource) {
    doSomethingWith(resource);
  });
});
</code></pre>
<p>But there is a problem: in this case, webEditors has its own dependency on bajaux, but the two files get downloaded in parallel. It&rsquo;s a race against time: if the bajaux builtfile isn&rsquo;t fully downloaded by the time webEditors is downloaded, then webEditors will start pulling its bajaux dependencies too soon. As a result, say, Widget.js might get downloaded, even though it&rsquo;s totally unnecessary - Widget is defined in bajaux.built.min, it just hasn&rsquo;t been downloaded yet. We need a way of ensuring that JavaScript builtfiles are downloaded in the correct order to prevent unnecessary network traffic.</p>
<p><code>BIWebResource</code> solves this problem as well. It solves a graph of dependencies (<code>BJsBuild</code>s and <code>BCssResource</code>s) and arranges them into an array of arrays. The dependencies in each array can be <code>require()</code>d concurrently, but each array&rsquo;s worth must be fully resolved before moving onto the next. This ensures that all dependencies are correctly satisfied.</p>
<p>In practice, this will likely not affect your day-to-day development - all the relevant places in the Niagara Framework have been updated to correctly resolve these dependencies. But if you have any places where you are manually resolving <code>BJsBuild</code> dependencies, <code>BIWebResource#resolve</code> will solve the graph, and <code>toJSON</code> will provide you with a JSON representation of the solved dependencies as RequireJS IDs.</p>
<p>As a minor side effect of this change, webdev behavior for <code>bajaScript</code> has also changed. Previously, turning on <code>webdev</code> for <code>bajaScript</code> would also disable the use of builtfiles for all <code>BIBajaScriptTypeExt</code>s. Now, the webdev settings for all type extensions will be respected, regardless of <code>bajaScript</code>&rsquo;s webdev setting.</p>
<p>In a unit test context, your Type Extensions may now try to load builtfiles they weren&rsquo;t loading before. If this occurs, simply add a line to your <code>srcTest/rc/browserMain.js</code>, before running the actual specs, that tells RequireJS to skip loading that builtfile:</p>
<pre><code class="jsx">define('nmodule/myModule/rc/myModult.built.min');
</code></pre>
<h4 id="breaking-change">Breaking change</h4>
<p>If you have your own implementation of <code>BIBajaScriptTypeExt</code> that overrides <code>encodeToJson()</code>, it must be updated to encode an array-of-arrays instead of a flat array, as before. Please see the breaking change notification in the 4.13 documentation.</p>
<h2 id="niagara-412">Niagara 4.12</h2>
<h3 id="javascript-playground-examples-have-been-updated">Javascript playground examples have been updated</h3>
<p>The JavaScript Playground examples in the docDeveloper module have been brought up to date. Additionally, spandrel examples have been added.</p>
<h3 id="bajaux-command-change-to-getdisplaynameformat-and-getdescriptionformat">Bajaux Command change to getDisplayNameFormat() and getDescriptionFormat()</h3>
<p>Starting in Niagara 4.12, <code>Command.getDisplayNameFormat()</code> and <code>Command.getDescriptionFormat()</code> will no longer return the resolved lexicon value when the <code>lex</code> parameter is provided in the constructor. They will instead return the <code>BFormat</code> lexicon entry used to resolve that value. This should make it easier to identify a <code>Command</code> by calling its <code>getDisplayFormat()</code> method. You can still obtain the resolved lexicon values by calling <code>Command.toDisplayName()</code> or <code>Command.toDescription()</code>.</p>
<pre><code class="javascript">var command = new Command({
  module: &quot;bajaux&quot;, 
  lex: &quot;commands.undo&quot;
});

console.log(command.getDisplayNameFormat()); //&quot;%lexicon(bajaux:commands.undo.displayName)%&quot;
command.toDisplayName().then((result) =&gt; console.log(result)); //&quot;Undo&quot;

console.log(command.getDescriptionFormat()); //&quot;%lexicon(bajaux:commands.undo.description)%&quot;
command.toDescription().then((result) =&gt; console.log(result)); //&quot;undo the last command invocation&quot;
</code></pre>
<h3 id="new-table-events">New Table events</h3>
<p>Starting in Niagara 4.12, <code>nmodule/webEditors/rc/wb/table/Table</code> will trigger new events in response to user interaction.</p>
<pre><code class="javascript">const CELL_ACTIVATED_EVENT = Table.CELL_ACTIVATED_EVENT;
const ROW_SELECTION_CHANGED_EVENT = Table.ROW_SELECTION_CHANGED_EVENT;

// given a DOM element in which a Table has been initialized:
dom.on(CELL_ACTIVATED_EVENT, function (e, table, row, column) {
  const selectedRowValue = row.getSubject();
  const selectedCellValue = column.getValueFor(row);
});

dom.on(ROW_SELECTION_CHANGED_EVENT, function (e, table) {
  const newSelectedRows = table.getSelectedRows();
});
</code></pre>
<h3 id="new-spandrel-features-for-412">New spandrel features for 4.12</h3>
<p>The following spandrel features have been added for 4.12:</p>
<ul>
  <li>Event handlers can now be applied from spandrel jsx. This removes the requirement to override doInitialize for events.</li>
  <li>The concept of widget <code>state</code> has been added in order to keep track of information beyond the value loaded into the widget. This data may also now be automatically bound to child widgets by using the <code>bind</code> and <code>bindKey</code> attributes.</li>
  <li>Sometimes spandrel will not update modified widgets due to it being considered dirty. Widgets can now be marked <code>lax</code> to instruct spandrel to be more aggressive about forcing new values into the widget.</li>
  <li>The <code>&lt;any /&gt;</code> tag has been added to provide a way for to get the proper widget for the loaded in value.</li>
</ul>
<p>Please refer to the spandrel documentation and examples provided in the javascript playground which discuss the above spandrel features in further detail.</p>
<h3 id="spandrel-bugs-fixed"><code>spandrel</code> bugs fixed</h3>
<ul>
  <li>When widget children change from an empty array, to an array with one or more children present, the newly added children are correctly rendered.</li>
</ul>
<h3 id="bajaabstimedefault-utc-offset-changed">baja.AbsTime.DEFAULT UTC offset changed</h3>
<p>The default UTC offset for baja.AbsTime.DEFAULT is now the UTC timezone.</p>
<h3 id="changes-to-dialogsjs-params">Changes to dialogs.js params</h3>
<p>A <code>text</code> parameter can now be passed in to dialogs.js similar to how <code>content</code> was in the past. The <code>text</code> passed in will be escaped whereas the <code>content</code> passed in will not. <code>text</code> and <code>content</code> cannot both be specified and doing so will result in an error.</p>
<p>Example with content:</p>
<pre><code class="javascript">dialogs.showOk({ 
  content: '&lt;script&gt; alert(&quot;uh oh&quot;); &lt;/script&gt;' // This will not be escaped and will open an alert dialog
});
</code></pre>
<p>Example with text:</p>
<pre><code class="javascript">dialogs.showOk({ 
  text: '&lt;script&gt; alert(&quot;uh oh&quot;); &lt;/script&gt;' // This will be escaped and will not open an alert dialog
});
</code></pre>
<h3 id="global-promise-disabled-in-eslint">Global Promise disabled in eslint</h3>
<p>&lsquo;Promise&rsquo; must now be imported explicitly in RequireJS in order for ESLint to pass. This ensures that the correct &lsquo;Promise&rsquo; object is being used whether it be from bluebird, native promises, etc.</p>
<p>Example:</p>
<pre><code>define([ 'Promise' ], function (Promise) {
    'use strict';
    
    function doSomethingWithAPromise() {
        return Promise.resolve();
    };
});
</code></pre>
<h3 id="command-error-handling">Command error handling</h3>
<p>Commands should now either show their own error or reject. If a command does both, it will result in there being more than one error shown.</p>
<p>Additionally, <code>Command#defaultNotifyUser</code> may be overridden to specify a custom way to show a command&rsquo;s error.</p>
<h2 id="niagara-411">Niagara 4.11</h2>
<h3 id="bajascript">BajaScript</h3>
<h4 id="bajaordmake"><code>baja.Ord.make()</code></h4>
<p><code>child</code> is now an optional argument - if <code>base</code> is present but <code>child</code> is omitted, <code>base</code> will be used.</p>
<pre><code>// previously, if child might sometimes not be present:
if (child) {
  return baja.Ord.make({ base, child });
} else {
  return baja.Ord.make(base);
}

// now:
return baja.Ord.make({ base, child }); // always works
</code></pre>
<h3 id="jquery-core-update">jQuery Core update</h3>
<p>jQuery Core has been updated to version 3.5.1 and comes with a breaking change to make the HTML construction safer. For more details, visit https://jquery.com/upgrade-guide/3.5/.</p>
<p>To avoid significant efforts to replace code, a shim has been added to restore the legacy behavior. This shim is turned on by default but there is a system property to turn it off.</p>
<pre><code>// When set to true, jQuery will perform strict pre-filtering of HTML.
// Apply caution, since turning this to true may also break some of your existing UX views.
niagara.requirejs.useJQueryStrictHtmlPrefilter=true
</code></pre>
<h4 id="unit-testing-jquery-module-reference-updated">Unit Testing - jQuery module reference updated</h4>
<p>The introduction of this shim also calls for some changes to your Niagara modules. Source files are largely unaffected at this moment, however, the unit test package in your module(s) may need an update to the browserMain.js file. An updated browserMain.js file with the shim looks like this now.</p>
<pre><code>require.config({
  baseUrl: '/base',
  paths: {
    //... paths
    jquery: '/module/js/rc/jquery/jquery.min',
    // ...more paths
  },
  map: {
    '*': {
      'jquery': 'nmodule/js/rc/shims/jquery/jquery'
    },
    'nmodule/js/rc/shims/jquery/jquery': {
      'jquery': 'jquery'
    }
  }
});
</code></pre>
<h3 id="undoable-commands">Undoable Commands</h3>
<p>There is now support for making commands undoable. This enables the user to undo / redo actions for a given command.</p>
<p>These commands will be undoable in the HTML5HxProfile on the web only and not in other hx profiles or workbench. The undoable history will only last during the current session, so the user will not be able to undo / redo invoked commands after browser refresh.</p>
<p>Commands can add this functionality by overriding the undoable method in the child command or passing an <code>undoable</code> to the base Command class. This undoable will specify:</p>
<ul>
  <li>implementation for what happens for undo / redo</li>
  <li>text to display to the user what the undo / redo will do</li>
  <li>whether the user can undo / redo the command</li>
</ul>
<p>An undoable implementation could look something like this:</p>
<pre><code class="javascript">new Command({
  undoable: {
    redo: () =&gt; console.log('implement redo logic here'),
    undo: () =&gt; console.log('implement undo logic here'),
    redoText: () =&gt; console.log('get the text displayed for a redo'),
    undoText: () =&gt; console.log('get the text displayed for a undo'),
    canRedo: () =&gt; console.log('determine if the redo can happen'),
    canUndo: () =&gt; console.log('determine if the undo can happen')
  } 
});
</code></pre>
<p>For more details, see the documentation for the Command class.</p>
<h3 id="birequirejsconfig-now-respects-webdev-settings-for-its-containing-module">BIRequireJsConfig now respects webdev settings for its containing module</h3>
<p>Previously, the JavaScript written to implement a <code>BIRequireJsConfig</code> would receive a <code>webdev</code> parameter that was set based on whether <code>webdev</code> was turned on for the <code>js</code> module. Now, that <code>webdev</code> parameter is set based on whether <code>webdev</code> is turned on for the <code>buildId</code> of the <code>BIRequireJsConfig</code> itself. (If your <code>BIRequireJsConfig</code> does not specify a <code>buildId</code>, then that <code>webdev</code> parameter will fall back to the <code>js</code> module as it was before.)</p>
<p>Please see the help section &ldquo;Building JavaScript Applications&rdquo; in Doc Developer for more info about <code>webdev</code> and build IDs.</p>
<h2 id="niagara-410u1">Niagara 4.10u1</h2>
<h3 id="moment-pikaday-changes">Moment / Pikaday changes</h3>
<p>Moment now has a dependency on bajaScript. This provides moment with certain locale information from the user&rsquo;s language settings. To avoid the bajaScript dependency, moment can be required directly using the full module path: require nmodule/js/rc/moment/moment.min.</p>
<p>Due to this change, pikaday must be required after moment to ensure it is able to use moment for formatting. Code similar to:</p>
<pre><code class="javascript">define([ 'moment', 'pikaday' ], function () {
    // Make use of pikaday / moment
});
</code></pre>
<p>would need to transition to:</p>
<pre><code class="javascript">define([ 'moment' ], function () {
    require([ 'pikaday' ], function () {
        // Make use of pikaday / moment
    });
});
</code></pre>
<p>This will ensure that pikaday can detect and make use of moment.</p>
<p>If your unit tests incorporate tests for different languages like German &lsquo;de&rsquo;, you may want to update your browserMain.js with the new location of the localized moment &lsquo;/module/js/rc/shims/moment/moment&rsquo; so that any calls to moment.startOf(&lsquo;week&rsquo;) return the correct day of the week based on the current locale.</p>
<h2 id="niagara-410">Niagara 4.10</h2>
<h3 id="bajascript">BajaScript</h3>
<h4 id="implicit-batching-introduced">Implicit batching introduced</h4>
<p>When BajaScript performs multiple network calls in quick succession, those network calls will automatically batch into a single WebSocket message. See the documentation for <a href="../jsdoc/bajaScript-ux/baja.comm.Batch.html">baja.comm.Batch</a> for full details.</p>
<h4 id="formatting-support-added-to-complexgetdisplay">Formatting support added to <code>Complex#getDisplay</code></h4>
<p>A context object can now be passed as the second argument to <code>getDisplay()</code>. The context will be used to format the display string, if possible. Only Simple types that have Type Extensions implemented will perform formatting; other types will use the unformatted display string sent from the server, as before. When a context is passed, <code>getDisplay()</code> will return a Promise.</p>
<p>The main use case for this change is <code>baja.Format</code>, which will now do a better job of respecting slot facets during formatting - most commonly for animating Widget properties in Px pages.</p>
<h3 id="bajaux">bajaux</h3>
<h4 id="spandrel-introduced"><code>spandrel</code> introduced</h4>
<p><code>spandrel</code> is a new API introduced to ease the process of constructing Widgets that contain nested child Widgets. It also allows the construction of <code>bajaux</code> widgets using JSX.</p>
<p>It does not replace <code>bajaux</code> - it is built on top of it. There is no requirement that you use it, but we think you may find it useful. Check the <code>bajaux</code> documentation for full details, including a tutorial.</p>
<h4 id="widget-constructor-receives-an-object-literal"><code>Widget</code> constructor receives an object literal</h4>
<p>The <code>Widget</code> constructor may now receive an object literal instead of three strings. The object literal specifies the Widget&rsquo;s starting configuration. The old-style constructor is still supported by the framework for now, but it is strongly recommended that you switch to the new style. Please see the <code>bajaux</code> documentation for full details.</p>
<pre><code>// old style.
// using this style, the initial set of properties passed to the constructor
// may not be respected because the add() call would overwrite them.
class MyWidget {
  constructor() {
    super(...arguments);
    this.properties().add('myProp', 'defaultValue');
  }
}
const w = new MyWidget({ properties: { myProp: 'myPropValue' } });
w.properties().getValue('myProp'); // defaultValue

// new style.
// using this style, the initial set of properties passed to the constructor
// will be respected, while still allowing for defaults.
class MyWidget {
  constructor(params) {
    super({
      params,
      defaults: { properties: { myProp: 'defaultValue' } }
    });
  }
}
const w = new MyWidget({ properties: { myProp: 'myPropValue' } });
w.properties().getValue('myProp'); // myPropValue
</code></pre>
<h4 id="widgetresolve-receives-viewqueries"><code>Widget#resolve</code> receives ViewQueries</h4>
<p>Previously, <code>view:</code> query parameters were stripped off before being passed to <code>Widget#resolve</code>. They are now included.</p>
<h3 id="uxbuilder">uxBuilder</h3>
<h4 id="uxmedia-introduced"><code>UxMedia</code> introduced</h4>
<p><code>UxMedia</code> is a new method of rendering Px graphics purely in the browser. See this <a href="uxMedia.html">overview of how it works</a>.</p>
<h3 id="webeditors">webEditors</h3>
<h4 id="febuildfor-no-longer-accepts-value-as-a-promise"><code>fe.buildFor()</code> no longer accepts <code>value</code> as a Promise</h4>
<p>If your value is a Promise, it must be resolved first.</p>
<pre><code>// no longer works:
return fe.buildFor({ value: getValueAsync() });

// must now be:
return getValueAsync()
  .then((value) =&gt; fe.buildFor({ value }));
</code></pre>
<h4 id="febuildfor-no-longer-rejects-if-a-widget-already-exists"><code>fe.buildFor()</code> no longer rejects if a Widget already exists</h4>
<p>If a Widget already exists in the DOM element you pass to <code>fe.buildFor()</code>, it will no longer reject - it will simply destroy the existing Widget before building a new one in its place.</p>

<script type='text/javascript'>window.niagara.docDevUtil.highlightCode();</script>

<!-- Auto-generated Footer NavBar --><p class="navbar">  <a href="/doc/index.html" class="navbar">Index</a> |  <a href="/doc/uiFromAxToN4.html" class="navbar">Prev</a> |  <a href="/doc/servingFromFileSys.html" class="navbar">Next</a></p>
<!-- Auto-generated copyright note --><p class='copyright'></p>
</body>
</html>
